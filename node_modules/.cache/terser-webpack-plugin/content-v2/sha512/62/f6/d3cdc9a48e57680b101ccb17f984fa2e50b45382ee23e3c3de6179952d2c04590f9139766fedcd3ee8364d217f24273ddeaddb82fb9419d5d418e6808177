{"map":"{\"version\":3,\"sources\":[\"../src/error.js\",\"../node_modules/kind-of/index.js\",\"../src/constants.js\",\"../src/utils.js\",\"../src/kinds.js\",\"../src/types.js\",\"../src/superstruct.js\",\"../src/index.js\"],\"names\":[\"StructError\",\"attrs\",\"_this\",\"_classCallCheck\",\"this\",\"message\",\"data\",\"path\",\"value\",\"reason\",\"type\",\"_attrs$errors\",\"errors\",\"length\",\"push\",\"Error\",\"captureStackTrace\",\"constructor\",\"stack\",\"TypeError\",\"JSON\",\"toString\",\"Object\",\"prototype\",\"kindOf\",\"val\",\"_typeof\",\"ctorName\",\"Array\",\"isArray\",\"isBuffer\",\"callee\",\"err\",\"indexOf\",\"isArguments\",\"Date\",\"toDateString\",\"getDate\",\"setDate\",\"isDate\",\"stackTraceLimit\",\"isError\",\"RegExp\",\"flags\",\"ignoreCase\",\"multiline\",\"global\",\"isRegexp\",\"next\",\"isGeneratorObj\",\"call\",\"slice\",\"toLowerCase\",\"replace\",\"name\",\"IS_STRUCT\",\"KIND\",\"isStruct\",\"resolveDefaults\",\"defaults\",\"Kind\",\"validate\",\"any\",\"schema\",\"defaults$$1\",\"options\",\"tuple\",\"list\",\"func\",\"object\",\"required\",\"union\",\"intersection\",\"scalar\",\"optional\",\"concat\",\"en\",\"map\",\"s\",\"e\",\"String\",\"join\",\"arguments\",\"undefined\",\"isValid\",\"result\",\"failure\",\"_extends\",\"array\",\"element\",\"_array$validate2\",\"_slicedToArray\",\"error\",\"ret\",\"_loop3\",\"i\",\"v\",\"_element$validate2\",\"r\",\"forEach\",\"singleE\",\"first\",\"obj\",\"ks\",\"properties\",\"key\",\"kind\",\"valueKeys\",\"propertiesKeys\",\"Set\",\"_kind$validate4\",\"_e2\",\"fn\",\"types\",\"_kind$validate8\",\"kinds\",\"k\",\"Math\",\"_loop5\",\"_e3\",\"_kind$validate10\",\"_iteratorNormalCompletion\",\"_didIteratorError\",\"_iteratorError\",\"_step\",\"_iterator\",\"Symbol\",\"iterator\",\"done\",\"_k2$validate2\",\"t\",\"_iteratorNormalCompletion2\",\"_didIteratorError2\",\"_iteratorError2\",\"_step2\",\"_iterator2\",\"_t$validate2\",\"Kinds\",\"keys\",\"values\",\"resolved\",\"_loop\",\"_k\",\"_keys$validate2\",\"_values$validate2\",\"e2\",\"r2\",\"_loop2\",\"_key\",\"_kind$validate2\",\"struct\",\"_loop4\",\"_key2\",\"_kind$validate6\",\"createSchema\",\"_schema$validate2\",\"Types\",\"superstruct\",\"config\",\"Struct\",\"defineProperty\",\"assert\",\"_kind$validate12\",\"test\",\"_kind$validate16\",\"TYPES\",\"isNaN\"],\"mappings\":\"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\",\"sourcesContent\":[\"/**\\n * Define a struct error.\\n *\\n * @type {StructError}\\n */\\n\\nclass StructError extends TypeError {\\n  static format(attrs) {\\n    const { type, path, value } = attrs\\n    const message = `Expected a value of type \\\\`${type}\\\\`${\\n      path.length ? ` for \\\\`${path.join('.')}\\\\`` : ''\\n    } but received \\\\`${JSON.stringify(value)}\\\\`.`\\n    return message\\n  }\\n\\n  constructor(attrs) {\\n    const message = StructError.format(attrs)\\n    super(message)\\n\\n    const { data, path, value, reason, type, errors = [] } = attrs\\n    this.data = data\\n    this.path = path\\n    this.value = value\\n    this.reason = reason\\n    this.type = type\\n    this.errors = errors\\n\\n    if (!errors.length) {\\n      errors.push(this)\\n    }\\n\\n    if (Error.captureStackTrace) {\\n      Error.captureStackTrace(this, this.constructor)\\n    } else {\\n      this.stack = new Error().stack\\n    }\\n  }\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {StructError}\\n */\\n\\nexport default StructError\\n\",\"var toString = Object.prototype.toString;\\n\\nmodule.exports = function kindOf(val) {\\n  if (val === void 0) return 'undefined';\\n  if (val === null) return 'null';\\n\\n  var type = typeof val;\\n  if (type === 'boolean') return 'boolean';\\n  if (type === 'string') return 'string';\\n  if (type === 'number') return 'number';\\n  if (type === 'symbol') return 'symbol';\\n  if (type === 'function') {\\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\\n  }\\n\\n  if (isArray(val)) return 'array';\\n  if (isBuffer(val)) return 'buffer';\\n  if (isArguments(val)) return 'arguments';\\n  if (isDate(val)) return 'date';\\n  if (isError(val)) return 'error';\\n  if (isRegexp(val)) return 'regexp';\\n\\n  switch (ctorName(val)) {\\n    case 'Symbol': return 'symbol';\\n    case 'Promise': return 'promise';\\n\\n    // Set, Map, WeakSet, WeakMap\\n    case 'WeakMap': return 'weakmap';\\n    case 'WeakSet': return 'weakset';\\n    case 'Map': return 'map';\\n    case 'Set': return 'set';\\n\\n    // 8-bit typed arrays\\n    case 'Int8Array': return 'int8array';\\n    case 'Uint8Array': return 'uint8array';\\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\\n\\n    // 16-bit typed arrays\\n    case 'Int16Array': return 'int16array';\\n    case 'Uint16Array': return 'uint16array';\\n\\n    // 32-bit typed arrays\\n    case 'Int32Array': return 'int32array';\\n    case 'Uint32Array': return 'uint32array';\\n    case 'Float32Array': return 'float32array';\\n    case 'Float64Array': return 'float64array';\\n  }\\n\\n  if (isGeneratorObj(val)) {\\n    return 'generator';\\n  }\\n\\n  // Non-plain objects\\n  type = toString.call(val);\\n  switch (type) {\\n    case '[object Object]': return 'object';\\n    // iterators\\n    case '[object Map Iterator]': return 'mapiterator';\\n    case '[object Set Iterator]': return 'setiterator';\\n    case '[object String Iterator]': return 'stringiterator';\\n    case '[object Array Iterator]': return 'arrayiterator';\\n  }\\n\\n  // other\\n  return type.slice(8, -1).toLowerCase().replace(/\\\\s/g, '');\\n};\\n\\nfunction ctorName(val) {\\n  return val.constructor ? val.constructor.name : null;\\n}\\n\\nfunction isArray(val) {\\n  if (Array.isArray) return Array.isArray(val);\\n  return val instanceof Array;\\n}\\n\\nfunction isError(val) {\\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\\n}\\n\\nfunction isDate(val) {\\n  if (val instanceof Date) return true;\\n  return typeof val.toDateString === 'function'\\n    && typeof val.getDate === 'function'\\n    && typeof val.setDate === 'function';\\n}\\n\\nfunction isRegexp(val) {\\n  if (val instanceof RegExp) return true;\\n  return typeof val.flags === 'string'\\n    && typeof val.ignoreCase === 'boolean'\\n    && typeof val.multiline === 'boolean'\\n    && typeof val.global === 'boolean';\\n}\\n\\nfunction isGeneratorFn(name, val) {\\n  return ctorName(name) === 'GeneratorFunction';\\n}\\n\\nfunction isGeneratorObj(val) {\\n  return typeof val.throw === 'function'\\n    && typeof val.return === 'function'\\n    && typeof val.next === 'function';\\n}\\n\\nfunction isArguments(val) {\\n  try {\\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\\n      return true;\\n    }\\n  } catch (err) {\\n    if (err.message.indexOf('callee') !== -1) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\n/**\\n * If you need to support Safari 5-7 (8-10 yr-old browser),\\n * take a look at https://github.com/feross/is-buffer\\n */\\n\\nfunction isBuffer(val) {\\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\\n    return val.constructor.isBuffer(val);\\n  }\\n  return false;\\n}\\n\",\"/**\\n * A private string to identify structs by.\\n *\\n * @type {String}\\n */\\n\\nconst IS_STRUCT = '@@__STRUCT__@@'\\n\\n/**\\n * A private string to refer to a struct's kind.\\n *\\n * @type {String}\\n */\\n\\nconst KIND = '@@__KIND__@@'\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nexport { IS_STRUCT, KIND }\\n\",\"import { IS_STRUCT } from './constants'\\n\\n/**\\n * Check if a `value` is a struct.\\n *\\n * @param {Any} value\\n * @return {Boolean}\\n */\\n\\nexport function isStruct(value) {\\n  return !!(value && value[IS_STRUCT])\\n}\\n\\n/**\\n * Resolve `defaults`, for an optional `value`.\\n *\\n * @param {Function|Any} defaults\\n * @param {Any} value\\n * @return {Any}\\n */\\n\\nexport function resolveDefaults(defaults, value) {\\n  return typeof defaults === 'function' ? defaults(value) : defaults\\n}\\n\",\"import kindOf from 'kind-of'\\n\\nimport { KIND } from './constants'\\nimport { isStruct, resolveDefaults } from './utils'\\n\\n/**\\n * Kind.\\n *\\n * @type {Kind}\\n */\\n\\nclass Kind {\\n  constructor(name, type, validate) {\\n    this.name = name\\n    this.type = type\\n    this.validate = validate\\n  }\\n}\\n\\n/**\\n * Any.\\n *\\n * @param {Array|Function|Object|String} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction any(schema, defaults, options) {\\n  if (isStruct(schema)) {\\n    return schema[KIND]\\n  }\\n\\n  if (schema instanceof Kind) {\\n    return schema\\n  }\\n\\n  switch (kindOf(schema)) {\\n    case 'array': {\\n      return schema.length > 1\\n        ? tuple(schema, defaults, options)\\n        : list(schema, defaults, options)\\n    }\\n\\n    case 'function': {\\n      return func(schema, defaults, options)\\n    }\\n\\n    case 'object': {\\n      return object(schema, defaults, options)\\n    }\\n\\n    case 'string': {\\n      let required = true\\n      let type\\n\\n      if (schema.endsWith('?')) {\\n        required = false\\n        schema = schema.slice(0, -1)\\n      }\\n\\n      if (schema.includes('|')) {\\n        const scalars = schema.split(/\\\\s*\\\\|\\\\s*/g)\\n        type = union(scalars, defaults, options)\\n      } else if (schema.includes('&')) {\\n        const scalars = schema.split(/\\\\s*&\\\\s*/g)\\n        type = intersection(scalars, defaults, options)\\n      } else {\\n        type = scalar(schema, defaults, options)\\n      }\\n\\n      if (!required) {\\n        type = optional(type, undefined, options)\\n      }\\n\\n      return type\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    throw new Error(\\n      `A schema definition must be an object, array, string or function, but you passed: ${schema}`\\n    )\\n  } else {\\n    throw new Error(`Invalid schema: ${schema}`)\\n  }\\n}\\n\\n/**\\n * Dict.\\n *\\n * @param {Array} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction dict(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Dict structs must be defined as an array with two elements, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const obj = scalar('object', undefined, options)\\n  const keys = any(schema[0], undefined, options)\\n  const values = any(schema[1], undefined, options)\\n  const name = 'dict'\\n  const type = `dict<${keys.type},${values.type}>`\\n  const validate = value => {\\n    const resolved = resolveDefaults(defaults)\\n    value = resolved ? { ...resolved, ...value } : value\\n    const [error] = obj.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const ret = {}\\n    const errors = []\\n\\n    for (let k in value) {\\n      const v = value[k]\\n      const [e, r] = keys.validate(k)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [k].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      k = r\\n      const [e2, r2] = values.validate(v)\\n\\n      if (e2) {\\n        const allE2 = e2.errors || [e2]\\n        allE2.forEach(singleE => {\\n          singleE.path = [k].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      ret[k] = r2\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Enum.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction en(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Enum structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const name = 'enum'\\n  const type = schema\\n    .map(s => {\\n      try {\\n        return JSON.stringify(s)\\n      } catch (e) {\\n        return String(s)\\n      }\\n    })\\n    .join(' | ')\\n\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    return schema.includes(value)\\n      ? [undefined, value]\\n      : [{ data: value, path: [], value, type }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Enums.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction enums(schema, defaults, options) {\\n  const e = en(schema, undefined, options)\\n  const l = list([e], defaults, options)\\n  return l\\n}\\n\\n/**\\n * Function.\\n *\\n * @param {Function} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction func(schema, defaults, options) {\\n  if (kindOf(schema) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Function structs must be defined as a function, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const name = 'function'\\n  const type = '<function>'\\n  const validate = (value = resolveDefaults(defaults), data) => {\\n    const result = schema(value, data)\\n    let failure = { path: [], reason: null }\\n    let isValid\\n\\n    switch (kindOf(result)) {\\n      case 'boolean': {\\n        isValid = result\\n        break\\n      }\\n      case 'string': {\\n        isValid = false\\n        failure.reason = result\\n        break\\n      }\\n      case 'object': {\\n        isValid = false\\n        failure = { ...failure, ...result }\\n        break\\n      }\\n      default: {\\n        if (process.env.NODE_ENV !== 'production') {\\n          throw new Error(\\n            `Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`\\n          )\\n        } else {\\n          throw new Error(`Invalid result: ${result}`)\\n        }\\n      }\\n    }\\n\\n    return isValid\\n      ? [undefined, value]\\n      : [{ type, value, data: value, ...failure }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Instance.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction instance(schema, defaults, options) {\\n  const name = 'instance'\\n  const type = `instance<${schema.name}>`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    return value instanceof schema\\n      ? [undefined, value]\\n      : [{ data: value, path: [], value, type }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Interface.\\n *\\n * @param {Object} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction inter(schema, defaults, options) {\\n  if (kindOf(schema) !== 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Interface structs must be defined as an object, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const ks = []\\n  const properties = {}\\n\\n  for (const key in schema) {\\n    ks.push(key)\\n    const s = schema[key]\\n    const kind = any(s, undefined, options)\\n    properties[key] = kind\\n  }\\n\\n  const name = 'interface'\\n  const type = `{${ks.join()}}`\\n  const validate = value => {\\n    const resolved = resolveDefaults(defaults)\\n    value = resolved ? { ...resolved, ...value } : value\\n    const errors = []\\n    const ret = value\\n\\n    for (const key in properties) {\\n      let v = value[key]\\n      const kind = properties[key]\\n\\n      if (v === undefined) {\\n        const d = defaults && defaults[key]\\n        v = resolveDefaults(d, value)\\n      }\\n\\n      const [e, r] = kind.validate(v, value)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [key].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      if (key in value || r !== undefined) {\\n        ret[key] = r\\n      }\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Lazy.\\n *\\n * @param {Function} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction lazy(schema, defaults, options) {\\n  if (kindOf(schema) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  let kind\\n  let struct\\n  const name = 'lazy'\\n  const type = `lazy...`\\n  const compile = value => {\\n    struct = schema()\\n    kind.name = struct.kind\\n    kind.type = struct.type\\n    kind.validate = struct.validate\\n    return kind.validate(value)\\n  }\\n\\n  kind = new Kind(name, type, compile)\\n  return kind\\n}\\n\\n/**\\n * Dynamic.\\n *\\n * @param {Function} createSchema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction dynamic(createSchema, defaults, options) {\\n  if (kindOf(createSchema) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Dynamic structs must be defined as a function, but you passed: ${createSchema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${createSchema}`)\\n    }\\n  }\\n\\n  const name = 'dynamic'\\n  const type = 'dynamic...'\\n  const validate = (value = resolveDefaults(defaults), data) => {\\n    const schema = createSchema(value, data)\\n\\n    if (kindOf(schema) !== 'function') {\\n      if (process.env.NODE_ENV !== 'production') {\\n        throw new Error(\\n          `Dynamic structs must return a schema, but you passed: ${schema}`\\n        )\\n      } else {\\n        throw new Error(`Invalid schema: ${schema}`)\\n      }\\n    }\\n\\n    const [error, result] = schema.validate(value)\\n\\n    if (error) {\\n      return [error]\\n    }\\n\\n    return [undefined, result]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * List.\\n *\\n * @param {Array} schema\\n * @param {Array} defaults\\n * @param {Object} options\\n */\\n\\nfunction list(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `List structs must be defined as an array with a single element, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const array = scalar('array', undefined, options)\\n  const element = any(schema[0], undefined, options)\\n  const name = 'list'\\n  const type = `[${element.type}]`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error, result] = array.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    value = result\\n    const errors = []\\n    const ret = []\\n\\n    for (let i = 0; i < value.length; i++) {\\n      const v = value[i]\\n      const [e, r] = element.validate(v)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [i].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      ret[i] = r\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Literal.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction literal(schema, defaults, options) {\\n  const name = 'literal'\\n  const type = `literal: ${JSON.stringify(schema)}`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    return value === schema\\n      ? [undefined, value]\\n      : [{ data: value, path: [], value, type }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Object.\\n *\\n * @param {Object} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction object(schema, defaults, options) {\\n  if (kindOf(schema) !== 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Object structs must be defined as an object, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const obj = scalar('object', undefined, options)\\n  const ks = []\\n  const properties = {}\\n\\n  for (const key in schema) {\\n    ks.push(key)\\n    const s = schema[key]\\n    const kind = any(s, undefined, options)\\n    properties[key] = kind\\n  }\\n\\n  const name = 'object'\\n  const type = `{${ks.join()}}`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error] = obj.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const errors = []\\n    const ret = {}\\n    const valueKeys = Object.keys(value)\\n    const propertiesKeys = Object.keys(properties)\\n    const keys = new Set(valueKeys.concat(propertiesKeys))\\n\\n    keys.forEach(key => {\\n      let v = value[key]\\n      const kind = properties[key]\\n\\n      if (v === undefined) {\\n        const d = defaults && defaults[key]\\n        v = resolveDefaults(d, value)\\n      }\\n\\n      if (!kind) {\\n        const e = { data: value, path: [key], value: v }\\n        errors.push(e)\\n        return\\n      }\\n\\n      const [e, r] = kind.validate(v, value)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [key].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        return\\n      }\\n\\n      if (key in value || r !== undefined) {\\n        ret[key] = r\\n      }\\n    })\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Optional.\\n *\\n * @param {Any} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction optional(schema, defaults, options) {\\n  return union([schema, 'undefined'], defaults, options)\\n}\\n\\n/**\\n * Partial.\\n *\\n * @param {Object} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction partial(schema, defaults, options) {\\n  if (kindOf(schema) !== 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Partial structs must be defined as an object, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const obj = scalar('object', undefined, options)\\n  const ks = []\\n  const properties = {}\\n\\n  for (const key in schema) {\\n    ks.push(key)\\n    const s = schema[key]\\n    const kind = any(s, undefined, options)\\n    properties[key] = kind\\n  }\\n\\n  const name = 'partial'\\n  const type = `{${ks.join()},...}`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error] = obj.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const errors = []\\n    const ret = {}\\n\\n    for (const key in properties) {\\n      let v = value[key]\\n      const kind = properties[key]\\n\\n      if (v === undefined) {\\n        const d = defaults && defaults[key]\\n        v = resolveDefaults(d, value)\\n      }\\n\\n      const [e, r] = kind.validate(v, value)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [key].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      if (key in value || r !== undefined) {\\n        ret[key] = r\\n      }\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Scalar.\\n *\\n * @param {String} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction scalar(schema, defaults, options) {\\n  if (kindOf(schema) !== 'string') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Scalar structs must be defined as a string, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const { types } = options\\n  const fn = types[schema]\\n\\n  if (kindOf(fn) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `No struct validator function found for type \\\"${schema}\\\".`\\n      )\\n    } else {\\n      throw new Error(`Invalid type: ${schema}`)\\n    }\\n  }\\n\\n  const kind = func(fn, defaults, options)\\n  const name = 'scalar'\\n  const type = schema\\n  const validate = value => {\\n    const [error, result] = kind.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    return [undefined, result]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Tuple.\\n *\\n * @param {Array} schema\\n * @param {Array} defaults\\n * @param {Object} options\\n */\\n\\nfunction tuple(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Tuple structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const kinds = schema.map(s => any(s, undefined, options))\\n  const array = scalar('array', undefined, options)\\n  const name = 'tuple'\\n  const type = `[${kinds.map(k => k.type).join()}]`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error] = array.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const ret = []\\n    const errors = []\\n    const length = Math.max(value.length, kinds.length)\\n\\n    for (let i = 0; i < length; i++) {\\n      const kind = kinds[i]\\n      const v = value[i]\\n\\n      if (!kind) {\\n        const e = { data: value, path: [i], value: v }\\n        errors.push(e)\\n        continue\\n      }\\n\\n      const [e, r] = kind.validate(v)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [i].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      ret[i] = r\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Union.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction union(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Union structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const kinds = schema.map(s => any(s, undefined, options))\\n  const name = 'union'\\n  const type = kinds.map(k => k.type).join(' | ')\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const errors = []\\n\\n    for (const k of kinds) {\\n      const [e, r] = k.validate(value)\\n\\n      if (!e) {\\n        return [undefined, r]\\n      }\\n\\n      errors.push(e)\\n    }\\n    errors[0].type = type\\n    return errors\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Intersection.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction intersection(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Intersection structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const types = schema.map(s => any(s, undefined, options))\\n  const name = 'intersection'\\n  const type = types.map(t => t.type).join(' & ')\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    let v = value\\n\\n    for (const t of types) {\\n      const [e, r] = t.validate(v)\\n\\n      if (e) {\\n        e.type = type\\n        return [e]\\n      }\\n\\n      v = r\\n    }\\n\\n    return [undefined, v]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Kinds.\\n *\\n * @type {Object}\\n */\\n\\nconst Kinds = {\\n  any,\\n  dict,\\n  enum: en,\\n  enums,\\n  function: func,\\n  instance,\\n  interface: inter,\\n  lazy,\\n  list,\\n  literal,\\n  object,\\n  optional,\\n  partial,\\n  scalar,\\n  tuple,\\n  union,\\n  intersection,\\n  dynamic,\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nexport default Kinds\\n\",\"import kindOf from 'kind-of'\\n\\n/**\\n * The types that `kind-of` supports.\\n *\\n * @type {Array}\\n */\\n\\nconst TYPES = [\\n  'arguments',\\n  'array',\\n  'boolean',\\n  'buffer',\\n  'error',\\n  'float32array',\\n  'float64array',\\n  'function',\\n  'generatorfunction',\\n  'int16array',\\n  'int32array',\\n  'int8array',\\n  'map',\\n  'null',\\n  'number',\\n  'object',\\n  'promise',\\n  'regexp',\\n  'set',\\n  'string',\\n  'symbol',\\n  'uint16array',\\n  'uint32array',\\n  'uint8array',\\n  'uint8clampedarray',\\n  'undefined',\\n  'weakmap',\\n  'weakset',\\n]\\n\\n/**\\n * The default types that Superstruct ships with.\\n *\\n * @type {Object}\\n */\\n\\nconst Types = {\\n  any: value => value !== undefined,\\n}\\n\\nTYPES.forEach(type => {\\n  Types[type] = value => kindOf(value) === type\\n})\\n\\n/**\\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\\n *\\n * @param {Mixed} value\\n * @return {Boolean}\\n */\\n\\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value)\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nexport default Types\\n\",\"import Kinds from './kinds'\\nimport StructError from './error'\\nimport Types from './types'\\nimport { isStruct } from './utils'\\nimport { IS_STRUCT, KIND } from './constants'\\n\\n/**\\n * Create a struct factory with a `config`.\\n *\\n * @param {Object} config\\n * @return {Function}\\n */\\n\\nfunction superstruct(config = {}) {\\n  const types = {\\n    ...Types,\\n    ...(config.types || {}),\\n  }\\n\\n  /**\\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\\n   *\\n   * @param {Any} schema\\n   * @param {Any} defaults\\n   * @param {Object} options\\n   * @return {Function}\\n   */\\n\\n  function struct(schema, defaults, options = {}) {\\n    if (isStruct(schema)) {\\n      schema = schema.schema\\n    }\\n\\n    const kind = Kinds.any(schema, defaults, { ...options, types })\\n\\n    function Struct(data) {\\n      if (this instanceof Struct) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          throw new Error(\\n            'The `Struct` creation function should not be used with the `new` keyword.'\\n          )\\n        } else {\\n          throw new Error('Invalid `new` keyword!')\\n        }\\n      }\\n\\n      return Struct.assert(data)\\n    }\\n\\n    Object.defineProperty(Struct, IS_STRUCT, { value: true })\\n    Object.defineProperty(Struct, KIND, { value: kind })\\n\\n    Struct.kind = kind.name\\n    Struct.type = kind.type\\n    Struct.schema = schema\\n    Struct.defaults = defaults\\n    Struct.options = options\\n\\n    Struct.assert = value => {\\n      const [error, result] = kind.validate(value)\\n\\n      if (error) {\\n        throw new StructError(error)\\n      }\\n\\n      return result\\n    }\\n\\n    Struct.test = value => {\\n      const [error] = kind.validate(value)\\n      return !error\\n    }\\n\\n    Struct.validate = value => {\\n      const [error, result] = kind.validate(value)\\n\\n      if (error) {\\n        return [new StructError(error)]\\n      }\\n\\n      return [undefined, result]\\n    }\\n\\n    return Struct\\n  }\\n\\n  /**\\n   * Mix in a factory for each specific kind of struct.\\n   */\\n\\n  Object.keys(Kinds).forEach(name => {\\n    const kind = Kinds[name]\\n\\n    struct[name] = (schema, defaults, options) => {\\n      const type = kind(schema, defaults, { ...options, types })\\n      const s = struct(type, defaults, options)\\n      return s\\n    }\\n  })\\n\\n  /**\\n   * Return the struct factory.\\n   */\\n\\n  return struct\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {Function}\\n */\\n\\nexport default superstruct\\n\",\"import StructError from './error'\\nimport superstruct from './superstruct'\\nimport { isStruct } from './utils'\\n\\n/**\\n * Create a convenience `struct` factory for the default types.\\n *\\n * @type {Function}\\n */\\n\\nconst struct = superstruct()\\n\\n/**\\n * Export.\\n *\\n * @type {Function}\\n */\\n\\nexport { struct, superstruct, isStruct, StructError }\\n\"]}","code":"(self.webpackJsonp=self.webpackJsonp||[]).push([[5],{230:function(r,t,n){\"use strict\";function e(r,t){return function(r){if(Array.isArray(r))return r}(r)||function(r,t){if(!(Symbol.iterator in Object(r)||\"[object Arguments]\"===Object.prototype.toString.call(r)))return;var n=[],e=!0,a=!1,o=void 0;try{for(var i,c=r[Symbol.iterator]();!(e=(i=c.next()).done)&&(n.push(i.value),!t||n.length!==t);e=!0);}catch(u){a=!0,o=u}finally{try{e||null==c.return||c.return()}finally{if(a)throw o}}return n}(r,t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()}function a(r){return(a=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(r){return typeof r}:function(r){return r&&\"function\"==typeof Symbol&&r.constructor===Symbol&&r!==Symbol.prototype?\"symbol\":typeof r})(r)}function o(r,t){if(!(r instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function i(r){if(void 0===r)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return r}function c(r,t){for(var n=0;n<t.length;n++){var e=t[n];e.enumerable=e.enumerable||!1,e.configurable=!0,\"value\"in e&&(e.writable=!0),Object.defineProperty(r,e.key,e)}}function u(r){var t=\"function\"==typeof Map?new Map:void 0;return(u=function(r){if(null===r||(n=r,-1===Function.toString.call(n).indexOf(\"[native code]\")))return r;var n;if(\"function\"!=typeof r)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==t){if(t.has(r))return t.get(r);t.set(r,e)}function e(){return f(r,arguments,s(this).constructor)}return e.prototype=Object.create(r.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),l(e,r)})(r)}function f(r,t,n){return(f=function(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(r){return!1}}()?Reflect.construct:function(r,t,n){var e=[null];e.push.apply(e,t);var a=new(Function.bind.apply(r,e));return n&&l(a,n.prototype),a}).apply(null,arguments)}function l(r,t){return(l=Object.setPrototypeOf||function(r,t){return r.__proto__=t,r})(r,t)}function s(r){return(s=Object.setPrototypeOf?Object.getPrototypeOf:function(r){return r.__proto__||Object.getPrototypeOf(r)})(r)}n.d(t,\"a\",function(){return M});var v=function(r){var t,n,e;function f(r){var t;o(this,f);var n,e,c=f.format(r);n=this,t=!(e=s(f).call(this,c))||\"object\"!==a(e)&&\"function\"!=typeof e?i(n):e;var u=r.data,l=r.path,v=r.value,p=r.reason,y=r.type,d=r.errors,h=void 0===d?[]:d;return t.data=u,t.path=l,t.value=v,t.reason=p,t.type=y,t.errors=h,h.length||h.push(i(t)),Error.captureStackTrace?Error.captureStackTrace(i(t),t.constructor):t.stack=(new Error).stack,t}return function(r,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function\");r.prototype=Object.create(t&&t.prototype,{constructor:{value:r,writable:!0,configurable:!0}}),t&&l(r,t)}(f,u(TypeError)),t=f,e=[{key:\"format\",value:function(r){var t=r.type,n=r.path,e=r.value;return\"Expected a value of type `\".concat(t,\"`\").concat(n.length?\" for `\".concat(n.join(\".\"),\"`\"):\"\",\" but received `\").concat(JSON.stringify(e),\"`.\")}}],(n=null)&&c(t.prototype,n),e&&c(t,e),f}(),p=Object.prototype.toString,y=function(r){if(void 0===r)return\"undefined\";if(null===r)return\"null\";var t=a(r);if(\"boolean\"===t)return\"boolean\";if(\"string\"===t)return\"string\";if(\"number\"===t)return\"number\";if(\"symbol\"===t)return\"symbol\";if(\"function\"===t)return\"GeneratorFunction\"===d(r)?\"generatorfunction\":\"function\";if(function(r){return Array.isArray?Array.isArray(r):r instanceof Array}(r))return\"array\";if(function(r){if(r.constructor&&\"function\"==typeof r.constructor.isBuffer)return r.constructor.isBuffer(r);return!1}(r))return\"buffer\";if(function(r){try{if(\"number\"==typeof r.length&&\"function\"==typeof r.callee)return!0}catch(t){if(-1!==t.message.indexOf(\"callee\"))return!0}return!1}(r))return\"arguments\";if(function(r){return r instanceof Date||\"function\"==typeof r.toDateString&&\"function\"==typeof r.getDate&&\"function\"==typeof r.setDate}(r))return\"date\";if(function(r){return r instanceof Error||\"string\"==typeof r.message&&r.constructor&&\"number\"==typeof r.constructor.stackTraceLimit}(r))return\"error\";if(function(r){return r instanceof RegExp||\"string\"==typeof r.flags&&\"boolean\"==typeof r.ignoreCase&&\"boolean\"==typeof r.multiline&&\"boolean\"==typeof r.global}(r))return\"regexp\";switch(d(r)){case\"Symbol\":return\"symbol\";case\"Promise\":return\"promise\";case\"WeakMap\":return\"weakmap\";case\"WeakSet\":return\"weakset\";case\"Map\":return\"map\";case\"Set\":return\"set\";case\"Int8Array\":return\"int8array\";case\"Uint8Array\":return\"uint8array\";case\"Uint8ClampedArray\":return\"uint8clampedarray\";case\"Int16Array\":return\"int16array\";case\"Uint16Array\":return\"uint16array\";case\"Int32Array\":return\"int32array\";case\"Uint32Array\":return\"uint32array\";case\"Float32Array\":return\"float32array\";case\"Float64Array\":return\"float64array\"}if(function(r){return\"function\"==typeof r.throw&&\"function\"==typeof r.return&&\"function\"==typeof r.next}(r))return\"generator\";switch(t=p.call(r)){case\"[object Object]\":return\"object\";case\"[object Map Iterator]\":return\"mapiterator\";case\"[object Set Iterator]\":return\"setiterator\";case\"[object String Iterator]\":return\"stringiterator\";case\"[object Array Iterator]\":return\"arrayiterator\"}return t.slice(8,-1).toLowerCase().replace(/\\s/g,\"\")};function d(r){return r.constructor?r.constructor.name:null}var h=\"@@__STRUCT__@@\",b=\"@@__KIND__@@\";function w(r){return!(!r||!r[h])}function m(r,t){return\"function\"==typeof r?r(t):r}var g=Object.assign||function(r){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var e in n)Object.prototype.hasOwnProperty.call(n,e)&&(r[e]=n[e])}return r},j=function r(t,n,e){o(this,r),this.name=t,this.type=n,this.validate=e};function E(r,t,n){if(w(r))return r[b];if(r instanceof j)return r;switch(y(r)){case\"array\":return r.length>1?x(r,t,n):I(r,t,n);case\"function\":return O(r,t,n);case\"object\":return k(r,t,n);case\"string\":var e,a=!0;if(r.endsWith(\"?\")&&(a=!1,r=r.slice(0,-1)),r.includes(\"|\"))e=P(r.split(/\\s*\\|\\s*/g),t,n);else if(r.includes(\"&\")){e=T(r.split(/\\s*&\\s*/g),t,n)}else e=_(r,t,n);return a||(e=A(e,void 0,n)),e}throw new Error(\"Invalid schema: \".concat(r))}function S(r,t,n){if(\"array\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));var e=r.map(function(r){try{return JSON.stringify(r)}catch(t){return String(r)}}).join(\" | \");return new j(\"enum\",e,function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t);return r.includes(n)?[void 0,n]:[{data:n,path:[],value:n,type:e}]})}function O(r,t,n){if(\"function\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));return new j(\"function\",\"<function>\",function(){var n,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t),a=arguments.length>1?arguments[1]:void 0,o=r(e,a),i={path:[],reason:null};switch(y(o)){case\"boolean\":n=o;break;case\"string\":n=!1,i.reason=o;break;case\"object\":n=!1,i=g({},i,o);break;default:throw new Error(\"Invalid result: \".concat(o))}return n?[void 0,e]:[g({type:\"<function>\",value:e,data:e},i)]})}function I(r,t,n){if(\"array\"!==y(r)||1!==r.length)throw new Error(\"Invalid schema: \".concat(r));var a=_(\"array\",void 0,n),o=E(r[0],void 0,n),i=\"[\".concat(o.type,\"]\");return new j(\"list\",i,function(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t),n=e(a.validate(r),2),c=n[0],u=n[1];if(c)return c.type=i,[c];r=u;for(var f=[],l=[],s=function(t){var n=r[t],a=e(o.validate(n),2),i=a[0],c=a[1];if(i)return(i.errors||[i]).forEach(function(n){n.path=[t].concat(n.path),n.data=r,f.push(n)}),\"continue\";l[t]=c},v=0;v<r.length;v++)s(v);if(f.length){var p=f[0];return p.errors=f,[p]}return[void 0,l]})}function k(r,t,n){if(\"object\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));var a=_(\"object\",void 0,n),o=[],i={};for(var c in r){o.push(c);var u=E(r[c],void 0,n);i[c]=u}var f=\"{\".concat(o.join(),\"}\");return new j(\"object\",f,function(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t),n=e(a.validate(r),1)[0];if(n)return n.type=f,[n];var o=[],c={},u=Object.keys(r),l=Object.keys(i);if(new Set(u.concat(l)).forEach(function(n){var a=r[n],u=i[n];if(void 0===a&&(a=m(t&&t[n],r)),u){var f=e(u.validate(a,r),2),l=f[0],s=f[1];l?(l.errors||[l]).forEach(function(t){t.path=[n].concat(t.path),t.data=r,o.push(t)}):(n in r||void 0!==s)&&(c[n]=s)}else{var v={data:r,path:[n],value:a};o.push(v)}}),o.length){var s=o[0];return s.errors=o,[s]}return[void 0,c]})}function A(r,t,n){return P([r,\"undefined\"],t,n)}function _(r,t,n){if(\"string\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));var a=n.types[r];if(\"function\"!==y(a))throw new Error(\"Invalid type: \".concat(r));var o=O(a,t),i=r;return new j(\"scalar\",i,function(r){var t=e(o.validate(r),2),n=t[0],a=t[1];return n?(n.type=i,[n]):[void 0,a]})}function x(r,t,n){if(\"array\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));var a=r.map(function(r){return E(r,void 0,n)}),o=_(\"array\",void 0,n),i=\"[\".concat(a.map(function(r){return r.type}).join(),\"]\");return new j(\"tuple\",i,function(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t),n=e(o.validate(r),1)[0];if(n)return n.type=i,[n];for(var c=[],u=[],f=Math.max(r.length,a.length),l=function(t){var n=a[t],o=r[t];if(!n){var i={data:r,path:[t],value:o};return u.push(i),\"continue\"}var f=e(n.validate(o),2),l=f[0],s=f[1];if(l)return(l.errors||[l]).forEach(function(n){n.path=[t].concat(n.path),n.data=r,u.push(n)}),\"continue\";c[t]=s},s=0;s<f;s++)l(s);if(u.length){var v=u[0];return v.errors=u,[v]}return[void 0,c]})}function P(r,t,n){if(\"array\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));var a=r.map(function(r){return E(r,void 0,n)}),o=a.map(function(r){return r.type}).join(\" | \");return new j(\"union\",o,function(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t),n=[],i=!0,c=!1,u=void 0;try{for(var f,l=a[Symbol.iterator]();!(i=(f=l.next()).done);i=!0){var s=e(f.value.validate(r),2),v=s[0],p=s[1];if(!v)return[void 0,p];n.push(v)}}catch(y){c=!0,u=y}finally{try{i||null==l.return||l.return()}finally{if(c)throw u}}return n[0].type=o,n})}function T(r,t,n){if(\"array\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));var a=r.map(function(r){return E(r,void 0,n)}),o=a.map(function(r){return r.type}).join(\" & \");return new j(\"intersection\",o,function(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t),n=!0,i=!1,c=void 0;try{for(var u,f=a[Symbol.iterator]();!(n=(u=f.next()).done);n=!0){var l=e(u.value.validate(r),2),s=l[0],v=l[1];if(s)return s.type=o,[s];r=v}}catch(p){i=!0,c=p}finally{try{n||null==f.return||f.return()}finally{if(i)throw c}}return[void 0,r]})}var R={any:E,dict:function(r,t,n){if(\"array\"!==y(r)||2!==r.length)throw new Error(\"Invalid schema: \".concat(r));var a=_(\"object\",void 0,n),o=E(r[0],void 0,n),i=E(r[1],void 0,n),c=\"dict<\".concat(o.type,\",\").concat(i.type,\">\");return new j(\"dict\",c,function(r){var n=m(t);r=n?g({},n,r):r;var u=e(a.validate(r),1)[0];if(u)return u.type=c,[u];var f={},l=[],s=function(t){var n=r[t],a=e(o.validate(t),2),c=a[0],u=a[1];if(c)return(c.errors||[c]).forEach(function(n){n.path=[t].concat(n.path),n.data=r,l.push(n)}),v=t,\"continue\";t=u;var s=e(i.validate(n),2),p=s[0],y=s[1];if(p)return(p.errors||[p]).forEach(function(n){n.path=[t].concat(n.path),n.data=r,l.push(n)}),v=t,\"continue\";f[t]=y,v=t};for(var v in r)s(v);if(l.length){var p=l[0];return p.errors=l,[p]}return[void 0,f]})},enum:S,enums:function(r,t,n){return I([S(r,void 0)],t,n)},function:O,instance:function(r,t,n){var e=\"instance<\".concat(r.name,\">\");return new j(\"instance\",e,function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t);return n instanceof r?[void 0,n]:[{data:n,path:[],value:n,type:e}]})},interface:function(r,t,n){if(\"object\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));var a=[],o={};for(var i in r){a.push(i);var c=E(r[i],void 0,n);o[i]=c}var u=\"{\".concat(a.join(),\"}\");return new j(\"interface\",u,function(r){var n=m(t);r=n?g({},n,r):r;var a=[],i=r,c=function(n){var c=r[n],u=o[n];void 0===c&&(c=m(t&&t[n],r));var f=e(u.validate(c,r),2),l=f[0],s=f[1];if(l)return(l.errors||[l]).forEach(function(t){t.path=[n].concat(t.path),t.data=r,a.push(t)}),\"continue\";(n in r||void 0!==s)&&(i[n]=s)};for(var u in o)c(u);if(a.length){var f=a[0];return f.errors=a,[f]}return[void 0,i]})},lazy:function(r,t,n){if(\"function\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));var e,a;return e=new j(\"lazy\",\"lazy...\",function(t){return a=r(),e.name=a.kind,e.type=a.type,e.validate=a.validate,e.validate(t)})},list:I,literal:function(r,t,n){var e=\"literal: \".concat(JSON.stringify(r));return new j(\"literal\",e,function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t);return n===r?[void 0,n]:[{data:n,path:[],value:n,type:e}]})},object:k,optional:A,partial:function(r,t,n){if(\"object\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));var a=_(\"object\",void 0,n),o=[],i={};for(var c in r){o.push(c);var u=E(r[c],void 0,n);i[c]=u}var f=\"{\".concat(o.join(),\",...}\");return new j(\"partial\",f,function(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t),n=e(a.validate(r),1)[0];if(n)return n.type=f,[n];var o=[],c={},u=function(n){var a=r[n],u=i[n];void 0===a&&(a=m(t&&t[n],r));var f=e(u.validate(a,r),2),l=f[0],s=f[1];if(l)return(l.errors||[l]).forEach(function(t){t.path=[n].concat(t.path),t.data=r,o.push(t)}),\"continue\";(n in r||void 0!==s)&&(c[n]=s)};for(var l in i)u(l);if(o.length){var s=o[0];return s.errors=o,[s]}return[void 0,c]})},scalar:_,tuple:x,union:P,intersection:T,dynamic:function(r,t,n){if(\"function\"!==y(r))throw new Error(\"Invalid schema: \".concat(r));return new j(\"dynamic\",\"dynamic...\",function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m(t),a=arguments.length>1?arguments[1]:void 0,o=r(n,a);if(\"function\"!==y(o))throw new Error(\"Invalid schema: \".concat(o));var i=e(o.validate(n),2),c=i[0],u=i[1];return c?[c]:[void 0,u]})}},D={any:function(r){return void 0!==r}};function M(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=g({},D,r.types||{});function n(r,n){var a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};w(r)&&(r=r.schema);var o=R.any(r,n,g({},a,{types:t}));function i(r){if(this instanceof i)throw new Error(\"Invalid `new` keyword!\");return i.assert(r)}return Object.defineProperty(i,h,{value:!0}),Object.defineProperty(i,b,{value:o}),i.kind=o.name,i.type=o.type,i.schema=r,i.defaults=n,i.options=a,i.assert=function(r){var t=e(o.validate(r),2),n=t[0],a=t[1];if(n)throw new v(n);return a},i.test=function(r){return!e(o.validate(r),1)[0]},i.validate=function(r){var t=e(o.validate(r),2),n=t[0],a=t[1];return n?[new v(n)]:[void 0,a]},i}return Object.keys(R).forEach(function(r){var e=R[r];n[r]=function(r,a,o){return n(e(r,a,g({},o,{types:t})),a,o)}}),n}[\"arguments\",\"array\",\"boolean\",\"buffer\",\"error\",\"float32array\",\"float64array\",\"function\",\"generatorfunction\",\"int16array\",\"int32array\",\"int8array\",\"map\",\"null\",\"number\",\"object\",\"promise\",\"regexp\",\"set\",\"string\",\"symbol\",\"uint16array\",\"uint32array\",\"uint8array\",\"uint8clampedarray\",\"undefined\",\"weakmap\",\"weakset\"].forEach(function(r){D[r]=function(t){return y(t)===r}}),D.date=function(r){return\"date\"===y(r)&&!isNaN(r)};M()}}]);","extractedComments":[]}