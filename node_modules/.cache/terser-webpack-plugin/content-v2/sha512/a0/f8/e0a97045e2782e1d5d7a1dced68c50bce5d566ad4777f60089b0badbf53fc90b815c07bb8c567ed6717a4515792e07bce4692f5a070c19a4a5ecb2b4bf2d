{"map":"{\"version\":3,\"sources\":[\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/panels/lovelace/common/structs/struct.ts\",\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/panels/lovelace/common/structs/is-entity-id.ts\",\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/panels/lovelace/common/structs/is-icon.ts\",\"../src/error.js\",\"../node_modules/kind-of/index.js\",\"../src/constants.js\",\"../src/utils.js\",\"../src/kinds.js\",\"../src/types.js\",\"../src/superstruct.js\",\"../src/index.js\",\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/resources/codemirror.ondemand.ts\",\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/components/ha-code-editor.ts\",\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/panels/lovelace/hui-editor.ts\"],\"names\":[\"__webpack_require__\",\"d\",\"__webpack_exports__\",\"struct\",\"superstruct\",\"types\",\"entity-id\",\"value\",\"includes\",\"icon\",\"StructError\",\"TypeError\",\"attrs\",\"type\",\"path\",\"JSON\",\"data\",\"reason\",\"errors\",\"length\",\"push\",\"this\",\"Error\",\"captureStackTrace\",\"constructor\",\"stack\",\"toString\",\"Object\",\"prototype\",\"kindOf\",\"val\",\"ctorName\",\"Array\",\"isArray\",\"isBuffer\",\"callee\",\"err\",\"message\",\"indexOf\",\"isArguments\",\"Date\",\"toDateString\",\"getDate\",\"setDate\",\"isDate\",\"stackTraceLimit\",\"isError\",\"RegExp\",\"flags\",\"ignoreCase\",\"multiline\",\"global\",\"isRegexp\",\"throw\",\"return\",\"next\",\"isGeneratorObj\",\"call\",\"slice\",\"toLowerCase\",\"replace\",\"name\",\"IS_STRUCT\",\"KIND\",\"isStruct\",\"resolveDefaults\",\"defaults\",\"Kind\",\"validate\",\"any\",\"schema\",\"defaults$$1\",\"options\",\"tuple\",\"list\",\"func\",\"object\",\"required\",\"union\",\"intersection\",\"scalar\",\"optional\",\"en\",\"map\",\"s\",\"e\",\"String\",\"join\",\"undefined\",\"result\",\"isValid\",\"failure\",\"_extends\",\"array\",\"element\",\"error\",\"ret\",\"i\",\"v\",\"r\",\"forEach\",\"singleE\",\"concat\",\"first\",\"obj\",\"ks\",\"properties\",\"key\",\"kind\",\"valueKeys\",\"propertiesKeys\",\"Set\",\"fn\",\"kinds\",\"k\",\"Math\",\"t\",\"Kinds\",\"dict\",\"keys\",\"values\",\"resolved\",\"e2\",\"r2\",\"enums\",\"instance\",\"lazy\",\"literal\",\"partial\",\"createSchema\",\"Types\",\"config\",\"Struct\",\"defineProperty\",\"assert\",\"test\",\"TYPES\",\"isNaN\",\"loaded\",\"_decorate\",\"customElement\",\"_initialize\",\"_UpdatingElement\",\"HaCodeEditor\",\"[object Object]\",\"args\",\"super\",\"F\",\"decorators\",\"property\",\"_value\",\"codemirror\",\"getValue\",\"shadowRoot\",\"querySelector\",\"_get\",\"_getPrototypeOf\",\"refresh\",\"autofocus\",\"focus\",\"changedProps\",\"has\",\"setOption\",\"mode\",\"setValue\",\"_calcGutters\",\"_setScrollBarDirection\",\"classList\",\"toggle\",\"_load\",\"async\",\"Promise\",\"all\",\"then\",\"bind\",\"loadCodeMirror\",\"codeMirror\",\"attachShadow\",\"innerHTML\",\"codeMirrorCss\",\"lineNumbers\",\"tabSize\",\"viewportMargin\",\"Infinity\",\"extraKeys\",\"Tab\",\"Shift-Tab\",\"gutters\",\"on\",\"_onChange\",\"newValue\",\"fireEvent\",\"rtl\",\"getWrapperElement\",\"UpdatingElement\",\"lovelaceStruct\",\"interface\",\"title\",\"views\",\"resources\",\"customElements\",\"define\",\"LitElement\",\"_defineProperty\",\"hass\",\"lovelace\",\"closeEditor\",\"_saving\",\"_changed\",\"render\",\"html\",\"_closeEditor\",\"localize\",\"classMap\",\"saved\",\"_handleSave\",\"computeRTL\",\"_yamlChanged\",\"firstUpdated\",\"yamlEditor\",\"safeDump\",\"styles\",\"haStyle\",\"css\",\"getDoc\",\"isClean\",\"_generation\",\"window\",\"onbeforeunload\",\"confirm\",\"hasComments\",\"safeLoad\",\"alert\",\"saveConfig\",\"changeGeneration\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { superstruct } from \\\"superstruct\\\";\\nimport { isEntityId } from \\\"./is-entity-id\\\";\\nimport { isIcon } from \\\"./is-icon\\\";\\n\\nexport const struct = superstruct({\\n  types: {\\n    \\\"entity-id\\\": isEntityId,\\n    icon: isIcon,\\n  },\\n});\\n\",\"export function isEntityId(value: any): string | boolean {\\n  if (typeof value !== \\\"string\\\") {\\n    return \\\"entity id should be a string\\\";\\n  }\\n  if (!value.includes(\\\".\\\")) {\\n    return \\\"entity id should be in the format 'domain.entity'\\\";\\n  }\\n  return true;\\n}\\n\",\"export function isIcon(value: any): string | boolean {\\n  if (typeof value !== \\\"string\\\") {\\n    return \\\"icon should be a string\\\";\\n  }\\n  if (!value.includes(\\\":\\\")) {\\n    return \\\"icon should be in the format 'mdi:icon'\\\";\\n  }\\n  return true;\\n}\\n\",\"/**\\n * Define a struct error.\\n *\\n * @type {StructError}\\n */\\n\\nclass StructError extends TypeError {\\n  static format(attrs) {\\n    const { type, path, value } = attrs\\n    const message = `Expected a value of type \\\\`${type}\\\\`${\\n      path.length ? ` for \\\\`${path.join('.')}\\\\`` : ''\\n    } but received \\\\`${JSON.stringify(value)}\\\\`.`\\n    return message\\n  }\\n\\n  constructor(attrs) {\\n    const message = StructError.format(attrs)\\n    super(message)\\n\\n    const { data, path, value, reason, type, errors = [] } = attrs\\n    this.data = data\\n    this.path = path\\n    this.value = value\\n    this.reason = reason\\n    this.type = type\\n    this.errors = errors\\n\\n    if (!errors.length) {\\n      errors.push(this)\\n    }\\n\\n    if (Error.captureStackTrace) {\\n      Error.captureStackTrace(this, this.constructor)\\n    } else {\\n      this.stack = new Error().stack\\n    }\\n  }\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {StructError}\\n */\\n\\nexport default StructError\\n\",\"var toString = Object.prototype.toString;\\n\\nmodule.exports = function kindOf(val) {\\n  if (val === void 0) return 'undefined';\\n  if (val === null) return 'null';\\n\\n  var type = typeof val;\\n  if (type === 'boolean') return 'boolean';\\n  if (type === 'string') return 'string';\\n  if (type === 'number') return 'number';\\n  if (type === 'symbol') return 'symbol';\\n  if (type === 'function') {\\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\\n  }\\n\\n  if (isArray(val)) return 'array';\\n  if (isBuffer(val)) return 'buffer';\\n  if (isArguments(val)) return 'arguments';\\n  if (isDate(val)) return 'date';\\n  if (isError(val)) return 'error';\\n  if (isRegexp(val)) return 'regexp';\\n\\n  switch (ctorName(val)) {\\n    case 'Symbol': return 'symbol';\\n    case 'Promise': return 'promise';\\n\\n    // Set, Map, WeakSet, WeakMap\\n    case 'WeakMap': return 'weakmap';\\n    case 'WeakSet': return 'weakset';\\n    case 'Map': return 'map';\\n    case 'Set': return 'set';\\n\\n    // 8-bit typed arrays\\n    case 'Int8Array': return 'int8array';\\n    case 'Uint8Array': return 'uint8array';\\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\\n\\n    // 16-bit typed arrays\\n    case 'Int16Array': return 'int16array';\\n    case 'Uint16Array': return 'uint16array';\\n\\n    // 32-bit typed arrays\\n    case 'Int32Array': return 'int32array';\\n    case 'Uint32Array': return 'uint32array';\\n    case 'Float32Array': return 'float32array';\\n    case 'Float64Array': return 'float64array';\\n  }\\n\\n  if (isGeneratorObj(val)) {\\n    return 'generator';\\n  }\\n\\n  // Non-plain objects\\n  type = toString.call(val);\\n  switch (type) {\\n    case '[object Object]': return 'object';\\n    // iterators\\n    case '[object Map Iterator]': return 'mapiterator';\\n    case '[object Set Iterator]': return 'setiterator';\\n    case '[object String Iterator]': return 'stringiterator';\\n    case '[object Array Iterator]': return 'arrayiterator';\\n  }\\n\\n  // other\\n  return type.slice(8, -1).toLowerCase().replace(/\\\\s/g, '');\\n};\\n\\nfunction ctorName(val) {\\n  return val.constructor ? val.constructor.name : null;\\n}\\n\\nfunction isArray(val) {\\n  if (Array.isArray) return Array.isArray(val);\\n  return val instanceof Array;\\n}\\n\\nfunction isError(val) {\\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\\n}\\n\\nfunction isDate(val) {\\n  if (val instanceof Date) return true;\\n  return typeof val.toDateString === 'function'\\n    && typeof val.getDate === 'function'\\n    && typeof val.setDate === 'function';\\n}\\n\\nfunction isRegexp(val) {\\n  if (val instanceof RegExp) return true;\\n  return typeof val.flags === 'string'\\n    && typeof val.ignoreCase === 'boolean'\\n    && typeof val.multiline === 'boolean'\\n    && typeof val.global === 'boolean';\\n}\\n\\nfunction isGeneratorFn(name, val) {\\n  return ctorName(name) === 'GeneratorFunction';\\n}\\n\\nfunction isGeneratorObj(val) {\\n  return typeof val.throw === 'function'\\n    && typeof val.return === 'function'\\n    && typeof val.next === 'function';\\n}\\n\\nfunction isArguments(val) {\\n  try {\\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\\n      return true;\\n    }\\n  } catch (err) {\\n    if (err.message.indexOf('callee') !== -1) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\n/**\\n * If you need to support Safari 5-7 (8-10 yr-old browser),\\n * take a look at https://github.com/feross/is-buffer\\n */\\n\\nfunction isBuffer(val) {\\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\\n    return val.constructor.isBuffer(val);\\n  }\\n  return false;\\n}\\n\",\"/**\\n * A private string to identify structs by.\\n *\\n * @type {String}\\n */\\n\\nconst IS_STRUCT = '@@__STRUCT__@@'\\n\\n/**\\n * A private string to refer to a struct's kind.\\n *\\n * @type {String}\\n */\\n\\nconst KIND = '@@__KIND__@@'\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nexport { IS_STRUCT, KIND }\\n\",\"import { IS_STRUCT } from './constants'\\n\\n/**\\n * Check if a `value` is a struct.\\n *\\n * @param {Any} value\\n * @return {Boolean}\\n */\\n\\nexport function isStruct(value) {\\n  return !!(value && value[IS_STRUCT])\\n}\\n\\n/**\\n * Resolve `defaults`, for an optional `value`.\\n *\\n * @param {Function|Any} defaults\\n * @param {Any} value\\n * @return {Any}\\n */\\n\\nexport function resolveDefaults(defaults, value) {\\n  return typeof defaults === 'function' ? defaults(value) : defaults\\n}\\n\",\"import kindOf from 'kind-of'\\n\\nimport { KIND } from './constants'\\nimport { isStruct, resolveDefaults } from './utils'\\n\\n/**\\n * Kind.\\n *\\n * @type {Kind}\\n */\\n\\nclass Kind {\\n  constructor(name, type, validate) {\\n    this.name = name\\n    this.type = type\\n    this.validate = validate\\n  }\\n}\\n\\n/**\\n * Any.\\n *\\n * @param {Array|Function|Object|String} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction any(schema, defaults, options) {\\n  if (isStruct(schema)) {\\n    return schema[KIND]\\n  }\\n\\n  if (schema instanceof Kind) {\\n    return schema\\n  }\\n\\n  switch (kindOf(schema)) {\\n    case 'array': {\\n      return schema.length > 1\\n        ? tuple(schema, defaults, options)\\n        : list(schema, defaults, options)\\n    }\\n\\n    case 'function': {\\n      return func(schema, defaults, options)\\n    }\\n\\n    case 'object': {\\n      return object(schema, defaults, options)\\n    }\\n\\n    case 'string': {\\n      let required = true\\n      let type\\n\\n      if (schema.endsWith('?')) {\\n        required = false\\n        schema = schema.slice(0, -1)\\n      }\\n\\n      if (schema.includes('|')) {\\n        const scalars = schema.split(/\\\\s*\\\\|\\\\s*/g)\\n        type = union(scalars, defaults, options)\\n      } else if (schema.includes('&')) {\\n        const scalars = schema.split(/\\\\s*&\\\\s*/g)\\n        type = intersection(scalars, defaults, options)\\n      } else {\\n        type = scalar(schema, defaults, options)\\n      }\\n\\n      if (!required) {\\n        type = optional(type, undefined, options)\\n      }\\n\\n      return type\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    throw new Error(\\n      `A schema definition must be an object, array, string or function, but you passed: ${schema}`\\n    )\\n  } else {\\n    throw new Error(`Invalid schema: ${schema}`)\\n  }\\n}\\n\\n/**\\n * Dict.\\n *\\n * @param {Array} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction dict(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Dict structs must be defined as an array with two elements, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const obj = scalar('object', undefined, options)\\n  const keys = any(schema[0], undefined, options)\\n  const values = any(schema[1], undefined, options)\\n  const name = 'dict'\\n  const type = `dict<${keys.type},${values.type}>`\\n  const validate = value => {\\n    const resolved = resolveDefaults(defaults)\\n    value = resolved ? { ...resolved, ...value } : value\\n    const [error] = obj.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const ret = {}\\n    const errors = []\\n\\n    for (let k in value) {\\n      const v = value[k]\\n      const [e, r] = keys.validate(k)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [k].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      k = r\\n      const [e2, r2] = values.validate(v)\\n\\n      if (e2) {\\n        const allE2 = e2.errors || [e2]\\n        allE2.forEach(singleE => {\\n          singleE.path = [k].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      ret[k] = r2\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Enum.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction en(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Enum structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const name = 'enum'\\n  const type = schema\\n    .map(s => {\\n      try {\\n        return JSON.stringify(s)\\n      } catch (e) {\\n        return String(s)\\n      }\\n    })\\n    .join(' | ')\\n\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    return schema.includes(value)\\n      ? [undefined, value]\\n      : [{ data: value, path: [], value, type }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Enums.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction enums(schema, defaults, options) {\\n  const e = en(schema, undefined, options)\\n  const l = list([e], defaults, options)\\n  return l\\n}\\n\\n/**\\n * Function.\\n *\\n * @param {Function} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction func(schema, defaults, options) {\\n  if (kindOf(schema) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Function structs must be defined as a function, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const name = 'function'\\n  const type = '<function>'\\n  const validate = (value = resolveDefaults(defaults), data) => {\\n    const result = schema(value, data)\\n    let failure = { path: [], reason: null }\\n    let isValid\\n\\n    switch (kindOf(result)) {\\n      case 'boolean': {\\n        isValid = result\\n        break\\n      }\\n      case 'string': {\\n        isValid = false\\n        failure.reason = result\\n        break\\n      }\\n      case 'object': {\\n        isValid = false\\n        failure = { ...failure, ...result }\\n        break\\n      }\\n      default: {\\n        if (process.env.NODE_ENV !== 'production') {\\n          throw new Error(\\n            `Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`\\n          )\\n        } else {\\n          throw new Error(`Invalid result: ${result}`)\\n        }\\n      }\\n    }\\n\\n    return isValid\\n      ? [undefined, value]\\n      : [{ type, value, data: value, ...failure }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Instance.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction instance(schema, defaults, options) {\\n  const name = 'instance'\\n  const type = `instance<${schema.name}>`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    return value instanceof schema\\n      ? [undefined, value]\\n      : [{ data: value, path: [], value, type }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Interface.\\n *\\n * @param {Object} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction inter(schema, defaults, options) {\\n  if (kindOf(schema) !== 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Interface structs must be defined as an object, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const ks = []\\n  const properties = {}\\n\\n  for (const key in schema) {\\n    ks.push(key)\\n    const s = schema[key]\\n    const kind = any(s, undefined, options)\\n    properties[key] = kind\\n  }\\n\\n  const name = 'interface'\\n  const type = `{${ks.join()}}`\\n  const validate = value => {\\n    const resolved = resolveDefaults(defaults)\\n    value = resolved ? { ...resolved, ...value } : value\\n    const errors = []\\n    const ret = value\\n\\n    for (const key in properties) {\\n      let v = value[key]\\n      const kind = properties[key]\\n\\n      if (v === undefined) {\\n        const d = defaults && defaults[key]\\n        v = resolveDefaults(d, value)\\n      }\\n\\n      const [e, r] = kind.validate(v, value)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [key].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      if (key in value || r !== undefined) {\\n        ret[key] = r\\n      }\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Lazy.\\n *\\n * @param {Function} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction lazy(schema, defaults, options) {\\n  if (kindOf(schema) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  let kind\\n  let struct\\n  const name = 'lazy'\\n  const type = `lazy...`\\n  const compile = value => {\\n    struct = schema()\\n    kind.name = struct.kind\\n    kind.type = struct.type\\n    kind.validate = struct.validate\\n    return kind.validate(value)\\n  }\\n\\n  kind = new Kind(name, type, compile)\\n  return kind\\n}\\n\\n/**\\n * Dynamic.\\n *\\n * @param {Function} createSchema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction dynamic(createSchema, defaults, options) {\\n  if (kindOf(createSchema) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Dynamic structs must be defined as a function, but you passed: ${createSchema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${createSchema}`)\\n    }\\n  }\\n\\n  const name = 'dynamic'\\n  const type = 'dynamic...'\\n  const validate = (value = resolveDefaults(defaults), data) => {\\n    const schema = createSchema(value, data)\\n\\n    if (kindOf(schema) !== 'function') {\\n      if (process.env.NODE_ENV !== 'production') {\\n        throw new Error(\\n          `Dynamic structs must return a schema, but you passed: ${schema}`\\n        )\\n      } else {\\n        throw new Error(`Invalid schema: ${schema}`)\\n      }\\n    }\\n\\n    const [error, result] = schema.validate(value)\\n\\n    if (error) {\\n      return [error]\\n    }\\n\\n    return [undefined, result]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * List.\\n *\\n * @param {Array} schema\\n * @param {Array} defaults\\n * @param {Object} options\\n */\\n\\nfunction list(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `List structs must be defined as an array with a single element, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const array = scalar('array', undefined, options)\\n  const element = any(schema[0], undefined, options)\\n  const name = 'list'\\n  const type = `[${element.type}]`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error, result] = array.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    value = result\\n    const errors = []\\n    const ret = []\\n\\n    for (let i = 0; i < value.length; i++) {\\n      const v = value[i]\\n      const [e, r] = element.validate(v)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [i].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      ret[i] = r\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Literal.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction literal(schema, defaults, options) {\\n  const name = 'literal'\\n  const type = `literal: ${JSON.stringify(schema)}`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    return value === schema\\n      ? [undefined, value]\\n      : [{ data: value, path: [], value, type }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Object.\\n *\\n * @param {Object} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction object(schema, defaults, options) {\\n  if (kindOf(schema) !== 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Object structs must be defined as an object, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const obj = scalar('object', undefined, options)\\n  const ks = []\\n  const properties = {}\\n\\n  for (const key in schema) {\\n    ks.push(key)\\n    const s = schema[key]\\n    const kind = any(s, undefined, options)\\n    properties[key] = kind\\n  }\\n\\n  const name = 'object'\\n  const type = `{${ks.join()}}`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error] = obj.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const errors = []\\n    const ret = {}\\n    const valueKeys = Object.keys(value)\\n    const propertiesKeys = Object.keys(properties)\\n    const keys = new Set(valueKeys.concat(propertiesKeys))\\n\\n    keys.forEach(key => {\\n      let v = value[key]\\n      const kind = properties[key]\\n\\n      if (v === undefined) {\\n        const d = defaults && defaults[key]\\n        v = resolveDefaults(d, value)\\n      }\\n\\n      if (!kind) {\\n        const e = { data: value, path: [key], value: v }\\n        errors.push(e)\\n        return\\n      }\\n\\n      const [e, r] = kind.validate(v, value)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [key].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        return\\n      }\\n\\n      if (key in value || r !== undefined) {\\n        ret[key] = r\\n      }\\n    })\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Optional.\\n *\\n * @param {Any} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction optional(schema, defaults, options) {\\n  return union([schema, 'undefined'], defaults, options)\\n}\\n\\n/**\\n * Partial.\\n *\\n * @param {Object} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction partial(schema, defaults, options) {\\n  if (kindOf(schema) !== 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Partial structs must be defined as an object, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const obj = scalar('object', undefined, options)\\n  const ks = []\\n  const properties = {}\\n\\n  for (const key in schema) {\\n    ks.push(key)\\n    const s = schema[key]\\n    const kind = any(s, undefined, options)\\n    properties[key] = kind\\n  }\\n\\n  const name = 'partial'\\n  const type = `{${ks.join()},...}`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error] = obj.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const errors = []\\n    const ret = {}\\n\\n    for (const key in properties) {\\n      let v = value[key]\\n      const kind = properties[key]\\n\\n      if (v === undefined) {\\n        const d = defaults && defaults[key]\\n        v = resolveDefaults(d, value)\\n      }\\n\\n      const [e, r] = kind.validate(v, value)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [key].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      if (key in value || r !== undefined) {\\n        ret[key] = r\\n      }\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Scalar.\\n *\\n * @param {String} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction scalar(schema, defaults, options) {\\n  if (kindOf(schema) !== 'string') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Scalar structs must be defined as a string, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const { types } = options\\n  const fn = types[schema]\\n\\n  if (kindOf(fn) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `No struct validator function found for type \\\"${schema}\\\".`\\n      )\\n    } else {\\n      throw new Error(`Invalid type: ${schema}`)\\n    }\\n  }\\n\\n  const kind = func(fn, defaults, options)\\n  const name = 'scalar'\\n  const type = schema\\n  const validate = value => {\\n    const [error, result] = kind.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    return [undefined, result]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Tuple.\\n *\\n * @param {Array} schema\\n * @param {Array} defaults\\n * @param {Object} options\\n */\\n\\nfunction tuple(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Tuple structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const kinds = schema.map(s => any(s, undefined, options))\\n  const array = scalar('array', undefined, options)\\n  const name = 'tuple'\\n  const type = `[${kinds.map(k => k.type).join()}]`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error] = array.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const ret = []\\n    const errors = []\\n    const length = Math.max(value.length, kinds.length)\\n\\n    for (let i = 0; i < length; i++) {\\n      const kind = kinds[i]\\n      const v = value[i]\\n\\n      if (!kind) {\\n        const e = { data: value, path: [i], value: v }\\n        errors.push(e)\\n        continue\\n      }\\n\\n      const [e, r] = kind.validate(v)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [i].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      ret[i] = r\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Union.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction union(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Union structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const kinds = schema.map(s => any(s, undefined, options))\\n  const name = 'union'\\n  const type = kinds.map(k => k.type).join(' | ')\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const errors = []\\n\\n    for (const k of kinds) {\\n      const [e, r] = k.validate(value)\\n\\n      if (!e) {\\n        return [undefined, r]\\n      }\\n\\n      errors.push(e)\\n    }\\n    errors[0].type = type\\n    return errors\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Intersection.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction intersection(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Intersection structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const types = schema.map(s => any(s, undefined, options))\\n  const name = 'intersection'\\n  const type = types.map(t => t.type).join(' & ')\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    let v = value\\n\\n    for (const t of types) {\\n      const [e, r] = t.validate(v)\\n\\n      if (e) {\\n        e.type = type\\n        return [e]\\n      }\\n\\n      v = r\\n    }\\n\\n    return [undefined, v]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Kinds.\\n *\\n * @type {Object}\\n */\\n\\nconst Kinds = {\\n  any,\\n  dict,\\n  enum: en,\\n  enums,\\n  function: func,\\n  instance,\\n  interface: inter,\\n  lazy,\\n  list,\\n  literal,\\n  object,\\n  optional,\\n  partial,\\n  scalar,\\n  tuple,\\n  union,\\n  intersection,\\n  dynamic,\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nexport default Kinds\\n\",\"import kindOf from 'kind-of'\\n\\n/**\\n * The types that `kind-of` supports.\\n *\\n * @type {Array}\\n */\\n\\nconst TYPES = [\\n  'arguments',\\n  'array',\\n  'boolean',\\n  'buffer',\\n  'error',\\n  'float32array',\\n  'float64array',\\n  'function',\\n  'generatorfunction',\\n  'int16array',\\n  'int32array',\\n  'int8array',\\n  'map',\\n  'null',\\n  'number',\\n  'object',\\n  'promise',\\n  'regexp',\\n  'set',\\n  'string',\\n  'symbol',\\n  'uint16array',\\n  'uint32array',\\n  'uint8array',\\n  'uint8clampedarray',\\n  'undefined',\\n  'weakmap',\\n  'weakset',\\n]\\n\\n/**\\n * The default types that Superstruct ships with.\\n *\\n * @type {Object}\\n */\\n\\nconst Types = {\\n  any: value => value !== undefined,\\n}\\n\\nTYPES.forEach(type => {\\n  Types[type] = value => kindOf(value) === type\\n})\\n\\n/**\\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\\n *\\n * @param {Mixed} value\\n * @return {Boolean}\\n */\\n\\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value)\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nexport default Types\\n\",\"import Kinds from './kinds'\\nimport StructError from './error'\\nimport Types from './types'\\nimport { isStruct } from './utils'\\nimport { IS_STRUCT, KIND } from './constants'\\n\\n/**\\n * Create a struct factory with a `config`.\\n *\\n * @param {Object} config\\n * @return {Function}\\n */\\n\\nfunction superstruct(config = {}) {\\n  const types = {\\n    ...Types,\\n    ...(config.types || {}),\\n  }\\n\\n  /**\\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\\n   *\\n   * @param {Any} schema\\n   * @param {Any} defaults\\n   * @param {Object} options\\n   * @return {Function}\\n   */\\n\\n  function struct(schema, defaults, options = {}) {\\n    if (isStruct(schema)) {\\n      schema = schema.schema\\n    }\\n\\n    const kind = Kinds.any(schema, defaults, { ...options, types })\\n\\n    function Struct(data) {\\n      if (this instanceof Struct) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          throw new Error(\\n            'The `Struct` creation function should not be used with the `new` keyword.'\\n          )\\n        } else {\\n          throw new Error('Invalid `new` keyword!')\\n        }\\n      }\\n\\n      return Struct.assert(data)\\n    }\\n\\n    Object.defineProperty(Struct, IS_STRUCT, { value: true })\\n    Object.defineProperty(Struct, KIND, { value: kind })\\n\\n    Struct.kind = kind.name\\n    Struct.type = kind.type\\n    Struct.schema = schema\\n    Struct.defaults = defaults\\n    Struct.options = options\\n\\n    Struct.assert = value => {\\n      const [error, result] = kind.validate(value)\\n\\n      if (error) {\\n        throw new StructError(error)\\n      }\\n\\n      return result\\n    }\\n\\n    Struct.test = value => {\\n      const [error] = kind.validate(value)\\n      return !error\\n    }\\n\\n    Struct.validate = value => {\\n      const [error, result] = kind.validate(value)\\n\\n      if (error) {\\n        return [new StructError(error)]\\n      }\\n\\n      return [undefined, result]\\n    }\\n\\n    return Struct\\n  }\\n\\n  /**\\n   * Mix in a factory for each specific kind of struct.\\n   */\\n\\n  Object.keys(Kinds).forEach(name => {\\n    const kind = Kinds[name]\\n\\n    struct[name] = (schema, defaults, options) => {\\n      const type = kind(schema, defaults, { ...options, types })\\n      const s = struct(type, defaults, options)\\n      return s\\n    }\\n  })\\n\\n  /**\\n   * Return the struct factory.\\n   */\\n\\n  return struct\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {Function}\\n */\\n\\nexport default superstruct\\n\",\"import StructError from './error'\\nimport superstruct from './superstruct'\\nimport { isStruct } from './utils'\\n\\n/**\\n * Create a convenience `struct` factory for the default types.\\n *\\n * @type {Function}\\n */\\n\\nconst struct = superstruct()\\n\\n/**\\n * Export.\\n *\\n * @type {Function}\\n */\\n\\nexport { struct, superstruct, isStruct, StructError }\\n\",\"interface LoadedCodeMirror {\\n  codeMirror: any;\\n  codeMirrorCss: any;\\n}\\n\\nlet loaded: Promise<LoadedCodeMirror>;\\n\\nexport const loadCodeMirror = async (): Promise<LoadedCodeMirror> => {\\n  if (!loaded) {\\n    loaded = import(/* webpackChunkName: \\\"codemirror\\\" */ \\\"./codemirror\\\");\\n  }\\n  return loaded;\\n};\\n\",\"import { loadCodeMirror } from \\\"../resources/codemirror.ondemand\\\";\\nimport { fireEvent } from \\\"../common/dom/fire_event\\\";\\nimport {\\n  UpdatingElement,\\n  property,\\n  customElement,\\n  PropertyValues,\\n} from \\\"lit-element\\\";\\nimport { Editor } from \\\"codemirror\\\";\\n\\ndeclare global {\\n  interface HASSDomEvents {\\n    \\\"editor-save\\\": undefined;\\n  }\\n}\\n\\n@customElement(\\\"ha-code-editor\\\")\\nexport class HaCodeEditor extends UpdatingElement {\\n  public codemirror?: Editor;\\n  @property() public mode?: string;\\n  @property() public autofocus = false;\\n  @property() public rtl = false;\\n  @property() public error = false;\\n  @property() private _value = \\\"\\\";\\n\\n  public set value(value: string) {\\n    this._value = value;\\n  }\\n\\n  public get value(): string {\\n    return this.codemirror ? this.codemirror.getValue() : this._value;\\n  }\\n\\n  public get hasComments(): boolean {\\n    return this.shadowRoot!.querySelector(\\\"span.cm-comment\\\") ? true : false;\\n  }\\n\\n  public connectedCallback() {\\n    super.connectedCallback();\\n    if (!this.codemirror) {\\n      return;\\n    }\\n    this.codemirror.refresh();\\n    if (this.autofocus !== false) {\\n      this.codemirror.focus();\\n    }\\n  }\\n\\n  protected update(changedProps: PropertyValues): void {\\n    super.update(changedProps);\\n\\n    if (!this.codemirror) {\\n      return;\\n    }\\n\\n    if (changedProps.has(\\\"mode\\\")) {\\n      this.codemirror.setOption(\\\"mode\\\", this.mode);\\n    }\\n    if (changedProps.has(\\\"autofocus\\\")) {\\n      this.codemirror.setOption(\\\"autofocus\\\", this.autofocus !== false);\\n    }\\n    if (changedProps.has(\\\"_value\\\") && this._value !== this.value) {\\n      this.codemirror.setValue(this._value);\\n    }\\n    if (changedProps.has(\\\"rtl\\\")) {\\n      this.codemirror.setOption(\\\"gutters\\\", this._calcGutters());\\n      this._setScrollBarDirection();\\n    }\\n    if (changedProps.has(\\\"error\\\")) {\\n      this.classList.toggle(\\\"error-state\\\", this.error);\\n    }\\n  }\\n\\n  protected firstUpdated(changedProps: PropertyValues): void {\\n    super.firstUpdated(changedProps);\\n    this._load();\\n  }\\n\\n  private async _load(): Promise<void> {\\n    const loaded = await loadCodeMirror();\\n\\n    const codeMirror = loaded.codeMirror;\\n\\n    const shadowRoot = this.attachShadow({ mode: \\\"open\\\" });\\n\\n    shadowRoot!.innerHTML = `\\n    <style>\\n      ${loaded.codeMirrorCss}\\n      .CodeMirror {\\n        height: var(--code-mirror-height, auto);\\n        direction: var(--code-mirror-direction, ltr);\\n      }\\n      .CodeMirror-scroll {\\n        max-height: var(--code-mirror-max-height, --code-mirror-height);\\n      }\\n      .CodeMirror-gutters {\\n        border-right: 1px solid var(--paper-input-container-color, var(--secondary-text-color));\\n        background-color: var(--paper-dialog-background-color, var(--primary-background-color));\\n        transition: 0.2s ease border-right;\\n      }\\n      :host(.error-state) .CodeMirror-gutters {\\n        border-color: var(--error-state-color, red);\\n      }\\n      .CodeMirror-focused .CodeMirror-gutters {\\n        border-right: 2px solid var(--paper-input-container-focus-color, var(--primary-color));\\n      }\\n      .CodeMirror-linenumber {\\n        color: var(--paper-dialog-color, var(--primary-text-color));\\n      }\\n      .rtl .CodeMirror-vscrollbar {\\n        right: auto;\\n        left: 0px;\\n      }\\n      .rtl-gutter {\\n        width: 20px;\\n      }\\n    </style>`;\\n\\n    this.codemirror = codeMirror(shadowRoot, {\\n      value: this._value,\\n      lineNumbers: true,\\n      tabSize: 2,\\n      mode: this.mode,\\n      autofocus: this.autofocus !== false,\\n      viewportMargin: Infinity,\\n      extraKeys: {\\n        Tab: \\\"indentMore\\\",\\n        \\\"Shift-Tab\\\": \\\"indentLess\\\",\\n      },\\n      gutters: this._calcGutters(),\\n    });\\n    this._setScrollBarDirection();\\n    this.codemirror!.on(\\\"changes\\\", () => this._onChange());\\n  }\\n\\n  private _onChange(): void {\\n    const newValue = this.value;\\n    if (newValue === this._value) {\\n      return;\\n    }\\n    this._value = newValue;\\n    fireEvent(this, \\\"value-changed\\\", { value: this._value });\\n  }\\n\\n  private _calcGutters(): string[] {\\n    return this.rtl ? [\\\"rtl-gutter\\\", \\\"CodeMirror-linenumbers\\\"] : [];\\n  }\\n\\n  private _setScrollBarDirection(): void {\\n    if (this.codemirror) {\\n      this.codemirror.getWrapperElement().classList.toggle(\\\"rtl\\\", this.rtl);\\n    }\\n  }\\n}\\n\\ndeclare global {\\n  interface HTMLElementTagNameMap {\\n    \\\"ha-code-editor\\\": HaCodeEditor;\\n  }\\n}\\n\",\"import { LitElement, html, TemplateResult, CSSResult, css } from \\\"lit-element\\\";\\nimport { classMap } from \\\"lit-html/directives/class-map\\\";\\nimport { safeDump, safeLoad } from \\\"js-yaml\\\";\\n\\nimport \\\"@polymer/app-layout/app-header-layout/app-header-layout\\\";\\nimport \\\"@polymer/app-layout/app-header/app-header\\\";\\nimport \\\"@polymer/app-layout/app-toolbar/app-toolbar\\\";\\nimport \\\"@material/mwc-button\\\";\\nimport \\\"@polymer/paper-icon-button/paper-icon-button\\\";\\nimport \\\"@polymer/paper-spinner/paper-spinner\\\";\\n\\nimport { struct } from \\\"./common/structs/struct\\\";\\nimport { Lovelace } from \\\"./types\\\";\\n\\nimport \\\"../../components/ha-icon\\\";\\nimport { haStyle } from \\\"../../resources/styles\\\";\\nimport \\\"../../components/ha-code-editor\\\";\\n// This is not a duplicate import, one is for types, one is for element.\\n// tslint:disable-next-line\\nimport { HaCodeEditor } from \\\"../../components/ha-code-editor\\\";\\nimport { HomeAssistant } from \\\"../../types\\\";\\nimport { computeRTL } from \\\"../../common/util/compute_rtl\\\";\\n\\nconst lovelaceStruct = struct.interface({\\n  title: \\\"string?\\\",\\n  views: [\\\"object\\\"],\\n  resources: struct.optional([\\\"object\\\"]),\\n});\\n\\nclass LovelaceFullConfigEditor extends LitElement {\\n  public hass!: HomeAssistant;\\n  public lovelace?: Lovelace;\\n  public closeEditor?: () => void;\\n  private _saving?: boolean;\\n  private _changed?: boolean;\\n  private _generation = 1;\\n\\n  static get properties() {\\n    return {\\n      hass: {},\\n      lovelace: {},\\n      closeEditor: {},\\n      _saving: {},\\n      _changed: {},\\n    };\\n  }\\n\\n  public render(): TemplateResult | void {\\n    return html`\\n      <app-header-layout>\\n        <app-header>\\n          <app-toolbar>\\n            <paper-icon-button\\n              icon=\\\"hass:close\\\"\\n              @click=\\\"${this._closeEditor}\\\"\\n            ></paper-icon-button>\\n            <div main-title>\\n              ${this.hass!.localize(\\n                \\\"ui.panel.lovelace.editor.raw_editor.header\\\"\\n              )}\\n            </div>\\n            <div\\n              class=\\\"save-button\\n              ${classMap({\\n                saved: this._saving! === false || this._changed === true,\\n              })}\\\"\\n            >\\n              ${this._changed\\n                ? this.hass!.localize(\\n                    \\\"ui.panel.lovelace.editor.raw_editor.unsaved_changes\\\"\\n                  )\\n                : this.hass!.localize(\\n                    \\\"ui.panel.lovelace.editor.raw_editor.saved\\\"\\n                  )}\\n            </div>\\n            <mwc-button raised @click=\\\"${this._handleSave}\\\"\\n              >${this.hass!.localize(\\n                \\\"ui.panel.lovelace.editor.raw_editor.save\\\"\\n              )}</mwc-button\\n            >\\n          </app-toolbar>\\n        </app-header>\\n        <div class=\\\"content\\\">\\n          <ha-code-editor\\n            mode=\\\"yaml\\\"\\n            autofocus\\n            .rtl=${computeRTL(this.hass)}\\n            .hass=\\\"${this.hass}\\\"\\n            @value-changed=\\\"${this._yamlChanged}\\\"\\n            @editor-save=\\\"${this._handleSave}\\\"\\n          >\\n          </ha-code-editor>\\n        </div>\\n      </app-header-layout>\\n    `;\\n  }\\n\\n  protected firstUpdated() {\\n    this.yamlEditor.value = safeDump(this.lovelace!.config);\\n  }\\n\\n  static get styles(): CSSResult[] {\\n    return [\\n      haStyle,\\n      css`\\n        :host {\\n          --code-mirror-height: 100%;\\n        }\\n\\n        app-header-layout {\\n          height: 100vh;\\n        }\\n\\n        app-toolbar {\\n          background-color: var(--dark-background-color, #455a64);\\n          color: var(--dark-text-color);\\n        }\\n\\n        .comments {\\n          font-size: 16px;\\n        }\\n\\n        .content {\\n          height: calc(100vh - 68px);\\n        }\\n\\n        hui-code-editor {\\n          height: 100%;\\n        }\\n\\n        .save-button {\\n          opacity: 0;\\n          font-size: 14px;\\n          padding: 0px 10px;\\n        }\\n\\n        .saved {\\n          opacity: 1;\\n        }\\n      `,\\n    ];\\n  }\\n\\n  private _yamlChanged() {\\n    this._changed = !this.yamlEditor\\n      .codemirror!.getDoc()\\n      .isClean(this._generation);\\n    if (this._changed && !window.onbeforeunload) {\\n      window.onbeforeunload = () => {\\n        return true;\\n      };\\n    } else if (!this._changed && window.onbeforeunload) {\\n      window.onbeforeunload = null;\\n    }\\n  }\\n\\n  private _closeEditor() {\\n    if (this._changed) {\\n      if (\\n        !confirm(\\n          this.hass.localize(\\n            \\\"ui.panel.lovelace.editor.raw_editor.confirm_unsaved_changes\\\"\\n          )\\n        )\\n      ) {\\n        return;\\n      }\\n    }\\n    window.onbeforeunload = null;\\n    if (this.closeEditor) {\\n      this.closeEditor();\\n    }\\n  }\\n\\n  private async _handleSave() {\\n    this._saving = true;\\n\\n    if (this.yamlEditor.hasComments) {\\n      if (\\n        !confirm(\\n          this.hass.localize(\\n            \\\"ui.panel.lovelace.editor.raw_editor.confirm_unsaved_comments\\\"\\n          )\\n        )\\n      ) {\\n        return;\\n      }\\n    }\\n\\n    let value;\\n    try {\\n      value = safeLoad(this.yamlEditor.value);\\n    } catch (err) {\\n      alert(\\n        this.hass.localize(\\n          \\\"ui.panel.lovelace.editor.raw_editor.error_parse_yaml\\\",\\n          \\\"error\\\",\\n          err\\n        )\\n      );\\n      this._saving = false;\\n      return;\\n    }\\n    try {\\n      value = lovelaceStruct(value);\\n    } catch (err) {\\n      alert(\\n        this.hass.localize(\\n          \\\"ui.panel.lovelace.editor.raw_editor.error_invalid_config\\\",\\n          \\\"error\\\",\\n          err\\n        )\\n      );\\n      return;\\n    }\\n    try {\\n      await this.lovelace!.saveConfig(value);\\n    } catch (err) {\\n      alert(\\n        this.hass.localize(\\n          \\\"ui.panel.lovelace.editor.raw_editor.error_save_yaml\\\",\\n          \\\"error\\\",\\n          err\\n        )\\n      );\\n    }\\n    this._generation = this.yamlEditor\\n      .codemirror!.getDoc()\\n      .changeGeneration(true);\\n    window.onbeforeunload = null;\\n    this._saving = false;\\n    this._changed = false;\\n  }\\n\\n  private get yamlEditor(): HaCodeEditor {\\n    return this.shadowRoot!.querySelector(\\\"ha-code-editor\\\")! as HaCodeEditor;\\n  }\\n}\\n\\ndeclare global {\\n  interface HTMLElementTagNameMap {\\n    \\\"hui-editor\\\": LovelaceFullConfigEditor;\\n  }\\n}\\n\\ncustomElements.define(\\\"hui-editor\\\", LovelaceFullConfigEditor);\\n\"]}","code":"(self.webpackJsonp=self.webpackJsonp||[]).push([[79],{189:function(e,t,r){\"use strict\";var n=r(200);r.d(t,\"a\",function(){return o});const o=Object(n.a)({types:{\"entity-id\":function(e){return\"string\"!=typeof e?\"entity id should be a string\":!!e.includes(\".\")||\"entity id should be in the format 'domain.entity'\"},icon:function(e){return\"string\"!=typeof e?\"icon should be a string\":!!e.includes(\":\")||\"icon should be in the format 'mdi:icon'\"}}})},200:function(e,t,r){\"use strict\";r.d(t,\"a\",function(){return O});class n extends TypeError{static format(e){const{type:t,path:r,value:n}=e;return`Expected a value of type \\`${t}\\`${r.length?` for \\`${r.join(\".\")}\\``:\"\"} but received \\`${JSON.stringify(n)}\\`.`}constructor(e){super(n.format(e));const{data:t,path:r,value:o,reason:i,type:a,errors:s=[]}=e;this.data=t,this.path=r,this.value=o,this.reason=i,this.type=a,this.errors=s,s.length||s.push(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack}}var o=Object.prototype.toString,i=function(e){if(void 0===e)return\"undefined\";if(null===e)return\"null\";var t=typeof e;if(\"boolean\"===t)return\"boolean\";if(\"string\"===t)return\"string\";if(\"number\"===t)return\"number\";if(\"symbol\"===t)return\"symbol\";if(\"function\"===t)return\"GeneratorFunction\"===a(e)?\"generatorfunction\":\"function\";if(function(e){return Array.isArray?Array.isArray(e):e instanceof Array}(e))return\"array\";if(function(e){if(e.constructor&&\"function\"==typeof e.constructor.isBuffer)return e.constructor.isBuffer(e);return!1}(e))return\"buffer\";if(function(e){try{if(\"number\"==typeof e.length&&\"function\"==typeof e.callee)return!0}catch(t){if(-1!==t.message.indexOf(\"callee\"))return!0}return!1}(e))return\"arguments\";if(function(e){return e instanceof Date||\"function\"==typeof e.toDateString&&\"function\"==typeof e.getDate&&\"function\"==typeof e.setDate}(e))return\"date\";if(function(e){return e instanceof Error||\"string\"==typeof e.message&&e.constructor&&\"number\"==typeof e.constructor.stackTraceLimit}(e))return\"error\";if(function(e){return e instanceof RegExp||\"string\"==typeof e.flags&&\"boolean\"==typeof e.ignoreCase&&\"boolean\"==typeof e.multiline&&\"boolean\"==typeof e.global}(e))return\"regexp\";switch(a(e)){case\"Symbol\":return\"symbol\";case\"Promise\":return\"promise\";case\"WeakMap\":return\"weakmap\";case\"WeakSet\":return\"weakset\";case\"Map\":return\"map\";case\"Set\":return\"set\";case\"Int8Array\":return\"int8array\";case\"Uint8Array\":return\"uint8array\";case\"Uint8ClampedArray\":return\"uint8clampedarray\";case\"Int16Array\":return\"int16array\";case\"Uint16Array\":return\"uint16array\";case\"Int32Array\":return\"int32array\";case\"Uint32Array\":return\"uint32array\";case\"Float32Array\":return\"float32array\";case\"Float64Array\":return\"float64array\"}if(function(e){return\"function\"==typeof e.throw&&\"function\"==typeof e.return&&\"function\"==typeof e.next}(e))return\"generator\";switch(t=o.call(e)){case\"[object Object]\":return\"object\";case\"[object Map Iterator]\":return\"mapiterator\";case\"[object Set Iterator]\":return\"setiterator\";case\"[object String Iterator]\":return\"stringiterator\";case\"[object Array Iterator]\":return\"arrayiterator\"}return t.slice(8,-1).toLowerCase().replace(/\\s/g,\"\")};function a(e){return e.constructor?e.constructor.name:null}const s=\"@@__STRUCT__@@\",c=\"@@__KIND__@@\";function l(e){return!(!e||!e[s])}function u(e,t){return\"function\"==typeof e?e(t):e}var d=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};class h{constructor(e,t,r){this.name=e,this.type=t,this.validate=r}}function f(e,t,r){if(l(e))return e[c];if(e instanceof h)return e;switch(i(e)){case\"array\":return e.length>1?w(e,t,r):y(e,t,r);case\"function\":return v(e,t,r);case\"object\":return m(e,t,r);case\"string\":{let n,o=!0;if(e.endsWith(\"?\")&&(o=!1,e=e.slice(0,-1)),e.includes(\"|\")){n=k(e.split(/\\s*\\|\\s*/g),t,r)}else if(e.includes(\"&\")){n=E(e.split(/\\s*&\\s*/g),t,r)}else n=b(e,t,r);return o||(n=g(n,void 0,r)),n}}throw new Error(`Invalid schema: ${e}`)}function p(e,t,r){if(\"array\"!==i(e))throw new Error(`Invalid schema: ${e}`);const n=e.map(e=>{try{return JSON.stringify(e)}catch(t){return String(e)}}).join(\" | \");return new h(\"enum\",n,(r=u(t))=>e.includes(r)?[void 0,r]:[{data:r,path:[],value:r,type:n}])}function v(e,t,r){if(\"function\"!==i(e))throw new Error(`Invalid schema: ${e}`);return new h(\"function\",\"<function>\",(r=u(t),n)=>{const o=e(r,n);let a,s={path:[],reason:null};switch(i(o)){case\"boolean\":a=o;break;case\"string\":a=!1,s.reason=o;break;case\"object\":a=!1,s=d({},s,o);break;default:throw new Error(`Invalid result: ${o}`)}return a?[void 0,r]:[d({type:\"<function>\",value:r,data:r},s)]})}function y(e,t,r){if(\"array\"!==i(e)||1!==e.length)throw new Error(`Invalid schema: ${e}`);const n=b(\"array\",void 0,r),o=f(e[0],void 0,r),a=`[${o.type}]`;return new h(\"list\",a,(e=u(t))=>{const[r,i]=n.validate(e);if(r)return r.type=a,[r];e=i;const s=[],c=[];for(let t=0;t<e.length;t++){const r=e[t],[n,i]=o.validate(r);n?(n.errors||[n]).forEach(r=>{r.path=[t].concat(r.path),r.data=e,s.push(r)}):c[t]=i}if(s.length){const e=s[0];return e.errors=s,[e]}return[void 0,c]})}function m(e,t,r){if(\"object\"!==i(e))throw new Error(`Invalid schema: ${e}`);const n=b(\"object\",void 0,r),o=[],a={};for(const i in e){o.push(i);const t=f(e[i],void 0,r);a[i]=t}const s=`{${o.join()}}`;return new h(\"object\",s,(e=u(t))=>{const[r]=n.validate(e);if(r)return r.type=s,[r];const o=[],i={},c=Object.keys(e),l=Object.keys(a);if(new Set(c.concat(l)).forEach(r=>{let n=e[r];const s=a[r];if(void 0===n&&(n=u(t&&t[r],e)),!s){const t={data:e,path:[r],value:n};return void o.push(t)}const[c,l]=s.validate(n,e);c?(c.errors||[c]).forEach(t=>{t.path=[r].concat(t.path),t.data=e,o.push(t)}):(r in e||void 0!==l)&&(i[r]=l)}),o.length){const e=o[0];return e.errors=o,[e]}return[void 0,i]})}function g(e,t,r){return k([e,\"undefined\"],t,r)}function b(e,t,r){if(\"string\"!==i(e))throw new Error(`Invalid schema: ${e}`);const{types:n}=r,o=n[e];if(\"function\"!==i(o))throw new Error(`Invalid type: ${e}`);const a=v(o,t),s=e;return new h(\"scalar\",s,e=>{const[t,r]=a.validate(e);return t?(t.type=s,[t]):[void 0,r]})}function w(e,t,r){if(\"array\"!==i(e))throw new Error(`Invalid schema: ${e}`);const n=e.map(e=>f(e,void 0,r)),o=b(\"array\",void 0,r),a=`[${n.map(e=>e.type).join()}]`;return new h(\"tuple\",a,(e=u(t))=>{const[r]=o.validate(e);if(r)return r.type=a,[r];const i=[],s=[],c=Math.max(e.length,n.length);for(let t=0;t<c;t++){const r=n[t],o=e[t];if(!r){const r={data:e,path:[t],value:o};s.push(r);continue}const[a,c]=r.validate(o);a?(a.errors||[a]).forEach(r=>{r.path=[t].concat(r.path),r.data=e,s.push(r)}):i[t]=c}if(s.length){const e=s[0];return e.errors=s,[e]}return[void 0,i]})}function k(e,t,r){if(\"array\"!==i(e))throw new Error(`Invalid schema: ${e}`);const n=e.map(e=>f(e,void 0,r)),o=n.map(e=>e.type).join(\" | \");return new h(\"union\",o,(e=u(t))=>{const r=[];for(const t of n){const[n,o]=t.validate(e);if(!n)return[void 0,o];r.push(n)}return r[0].type=o,r})}function E(e,t,r){if(\"array\"!==i(e))throw new Error(`Invalid schema: ${e}`);const n=e.map(e=>f(e,void 0,r)),o=n.map(e=>e.type).join(\" & \");return new h(\"intersection\",o,(e=u(t))=>{let r=e;for(const t of n){const[e,n]=t.validate(r);if(e)return e.type=o,[e];r=n}return[void 0,r]})}const _={any:f,dict:function(e,t,r){if(\"array\"!==i(e)||2!==e.length)throw new Error(`Invalid schema: ${e}`);const n=b(\"object\",void 0,r),o=f(e[0],void 0,r),a=f(e[1],void 0,r),s=`dict<${o.type},${a.type}>`;return new h(\"dict\",s,e=>{const r=u(t);e=r?d({},r,e):e;const[i]=n.validate(e);if(i)return i.type=s,[i];const c={},l=[];for(let t in e){const r=e[t],[n,i]=o.validate(t);if(n){(n.errors||[n]).forEach(r=>{r.path=[t].concat(r.path),r.data=e,l.push(r)});continue}t=i;const[s,u]=a.validate(r);s?(s.errors||[s]).forEach(r=>{r.path=[t].concat(r.path),r.data=e,l.push(r)}):c[t]=u}if(l.length){const e=l[0];return e.errors=l,[e]}return[void 0,c]})},enum:p,enums:function(e,t,r){return y([p(e,void 0)],t,r)},function:v,instance:function(e,t,r){const n=`instance<${e.name}>`;return new h(\"instance\",n,(r=u(t))=>r instanceof e?[void 0,r]:[{data:r,path:[],value:r,type:n}])},interface:function(e,t,r){if(\"object\"!==i(e))throw new Error(`Invalid schema: ${e}`);const n=[],o={};for(const i in e){n.push(i);const t=f(e[i],void 0,r);o[i]=t}const a=`{${n.join()}}`;return new h(\"interface\",a,e=>{const r=u(t);e=r?d({},r,e):e;const n=[],i=e;for(const a in o){let r=e[a];const s=o[a];void 0===r&&(r=u(t&&t[a],e));const[c,l]=s.validate(r,e);c?(c.errors||[c]).forEach(t=>{t.path=[a].concat(t.path),t.data=e,n.push(t)}):(a in e||void 0!==l)&&(i[a]=l)}if(n.length){const e=n[0];return e.errors=n,[e]}return[void 0,i]})},lazy:function(e,t,r){if(\"function\"!==i(e))throw new Error(`Invalid schema: ${e}`);let n,o;return n=new h(\"lazy\",\"lazy...\",t=>(o=e(),n.name=o.kind,n.type=o.type,n.validate=o.validate,n.validate(t)))},list:y,literal:function(e,t,r){const n=`literal: ${JSON.stringify(e)}`;return new h(\"literal\",n,(r=u(t))=>r===e?[void 0,r]:[{data:r,path:[],value:r,type:n}])},object:m,optional:g,partial:function(e,t,r){if(\"object\"!==i(e))throw new Error(`Invalid schema: ${e}`);const n=b(\"object\",void 0,r),o=[],a={};for(const i in e){o.push(i);const t=f(e[i],void 0,r);a[i]=t}const s=`{${o.join()},...}`;return new h(\"partial\",s,(e=u(t))=>{const[r]=n.validate(e);if(r)return r.type=s,[r];const o=[],i={};for(const n in a){let r=e[n];const s=a[n];void 0===r&&(r=u(t&&t[n],e));const[c,l]=s.validate(r,e);c?(c.errors||[c]).forEach(t=>{t.path=[n].concat(t.path),t.data=e,o.push(t)}):(n in e||void 0!==l)&&(i[n]=l)}if(o.length){const e=o[0];return e.errors=o,[e]}return[void 0,i]})},scalar:b,tuple:w,union:k,intersection:E,dynamic:function(e,t,r){if(\"function\"!==i(e))throw new Error(`Invalid schema: ${e}`);return new h(\"dynamic\",\"dynamic...\",(r=u(t),n)=>{const o=e(r,n);if(\"function\"!==i(o))throw new Error(`Invalid schema: ${o}`);const[a,s]=o.validate(r);return a?[a]:[void 0,s]})}},j={any:e=>void 0!==e};function O(e={}){const t=d({},j,e.types||{});function r(e,r,o={}){l(e)&&(e=e.schema);const i=_.any(e,r,d({},o,{types:t}));function a(e){if(this instanceof a)throw new Error(\"Invalid `new` keyword!\");return a.assert(e)}return Object.defineProperty(a,s,{value:!0}),Object.defineProperty(a,c,{value:i}),a.kind=i.name,a.type=i.type,a.schema=e,a.defaults=r,a.options=o,a.assert=(e=>{const[t,r]=i.validate(e);if(t)throw new n(t);return r}),a.test=(e=>{const[t]=i.validate(e);return!t}),a.validate=(e=>{const[t,r]=i.validate(e);return t?[new n(t)]:[void 0,r]}),a}return Object.keys(_).forEach(e=>{const n=_[e];r[e]=((e,o,i)=>{return r(n(e,o,d({},i,{types:t})),o,i)})}),r}[\"arguments\",\"array\",\"boolean\",\"buffer\",\"error\",\"float32array\",\"float64array\",\"function\",\"generatorfunction\",\"int16array\",\"int32array\",\"int8array\",\"map\",\"null\",\"number\",\"object\",\"promise\",\"regexp\",\"set\",\"string\",\"symbol\",\"uint16array\",\"uint32array\",\"uint8array\",\"uint8clampedarray\",\"undefined\",\"weakmap\",\"weakset\"].forEach(e=>{j[e]=(t=>i(t)===e)}),j.date=(e=>\"date\"===i(e)&&!isNaN(e));O()},238:function(e,t,r){\"use strict\";let n;var o=r(14),i=r(0);function a(e){var t,r=d(e.key);\"method\"===e.kind?t={value:e.value,writable:!0,configurable:!0,enumerable:!1}:\"get\"===e.kind?t={get:e.value,configurable:!0,enumerable:!1}:\"set\"===e.kind?t={set:e.value,configurable:!0,enumerable:!1}:\"field\"===e.kind&&(t={configurable:!0,writable:!0,enumerable:!0});var n={kind:\"field\"===e.kind?\"field\":\"method\",key:r,placement:e.static?\"static\":\"field\"===e.kind?\"own\":\"prototype\",descriptor:t};return e.decorators&&(n.decorators=e.decorators),\"field\"===e.kind&&(n.initializer=e.value),n}function s(e,t){void 0!==e.descriptor.get?t.descriptor.get=e.descriptor.get:t.descriptor.set=e.descriptor.set}function c(e){return e.decorators&&e.decorators.length}function l(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function u(e,t){var r=e[t];if(void 0!==r&&\"function\"!=typeof r)throw new TypeError(\"Expected '\"+t+\"' to be a function\");return r}function d(e){var t=function(e,t){if(\"object\"!=typeof e||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||\"default\");if(\"object\"!=typeof n)return n;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===t?String:Number)(e)}(e,\"string\");return\"symbol\"==typeof t?t:String(t)}function h(e,t,r){return(h=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,r){var n=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=f(e)););return e}(e,t);if(n){var o=Object.getOwnPropertyDescriptor(n,t);return o.get?o.get.call(r):o.value}})(e,t,r||e)}function f(e){return(f=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}!function(e,t,r,n){var o=function(){var e={elementsDefinitionOrder:[[\"method\"],[\"field\"]],initializeInstanceElements:function(e,t){[\"method\",\"field\"].forEach(function(r){t.forEach(function(t){t.kind===r&&\"own\"===t.placement&&this.defineClassElement(e,t)},this)},this)},initializeClassElements:function(e,t){var r=e.prototype;[\"method\",\"field\"].forEach(function(n){t.forEach(function(t){var o=t.placement;if(t.kind===n&&(\"static\"===o||\"prototype\"===o)){var i=\"static\"===o?e:r;this.defineClassElement(i,t)}},this)},this)},defineClassElement:function(e,t){var r=t.descriptor;if(\"field\"===t.kind){var n=t.initializer;r={enumerable:r.enumerable,writable:r.writable,configurable:r.configurable,value:void 0===n?void 0:n.call(e)}}Object.defineProperty(e,t.key,r)},decorateClass:function(e,t){var r=[],n=[],o={static:[],prototype:[],own:[]};if(e.forEach(function(e){this.addElementPlacement(e,o)},this),e.forEach(function(e){if(!c(e))return r.push(e);var t=this.decorateElement(e,o);r.push(t.element),r.push.apply(r,t.extras),n.push.apply(n,t.finishers)},this),!t)return{elements:r,finishers:n};var i=this.decorateConstructor(r,t);return n.push.apply(n,i.finishers),i.finishers=n,i},addElementPlacement:function(e,t,r){var n=t[e.placement];if(!r&&-1!==n.indexOf(e.key))throw new TypeError(\"Duplicated element (\"+e.key+\")\");n.push(e.key)},decorateElement:function(e,t){for(var r=[],n=[],o=e.decorators,i=o.length-1;i>=0;i--){var a=t[e.placement];a.splice(a.indexOf(e.key),1);var s=this.fromElementDescriptor(e),c=this.toElementFinisherExtras((0,o[i])(s)||s);e=c.element,this.addElementPlacement(e,t),c.finisher&&n.push(c.finisher);var l=c.extras;if(l){for(var u=0;u<l.length;u++)this.addElementPlacement(l[u],t);r.push.apply(r,l)}}return{element:e,finishers:n,extras:r}},decorateConstructor:function(e,t){for(var r=[],n=t.length-1;n>=0;n--){var o=this.fromClassDescriptor(e),i=this.toClassDescriptor((0,t[n])(o)||o);if(void 0!==i.finisher&&r.push(i.finisher),void 0!==i.elements){e=i.elements;for(var a=0;a<e.length-1;a++)for(var s=a+1;s<e.length;s++)if(e[a].key===e[s].key&&e[a].placement===e[s].placement)throw new TypeError(\"Duplicated element (\"+e[a].key+\")\")}}return{elements:e,finishers:r}},fromElementDescriptor:function(e){var t={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(t,Symbol.toStringTag,{value:\"Descriptor\",configurable:!0}),\"field\"===e.kind&&(t.initializer=e.initializer),t},toElementDescriptors:function(e){var t;if(void 0!==e)return(t=e,function(e){if(Array.isArray(e))return e}(t)||function(e){if(Symbol.iterator in Object(e)||\"[object Arguments]\"===Object.prototype.toString.call(e))return Array.from(e)}(t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()).map(function(e){var t=this.toElementDescriptor(e);return this.disallowProperty(e,\"finisher\",\"An element descriptor\"),this.disallowProperty(e,\"extras\",\"An element descriptor\"),t},this)},toElementDescriptor:function(e){var t=String(e.kind);if(\"method\"!==t&&\"field\"!==t)throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or \"field\", but a decorator created an element descriptor with .kind \"'+t+'\"');var r=d(e.key),n=String(e.placement);if(\"static\"!==n&&\"prototype\"!==n&&\"own\"!==n)throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\", \"prototype\" or \"own\", but a decorator created an element descriptor with .placement \"'+n+'\"');var o=e.descriptor;this.disallowProperty(e,\"elements\",\"An element descriptor\");var i={kind:t,key:r,placement:n,descriptor:Object.assign({},o)};return\"field\"!==t?this.disallowProperty(e,\"initializer\",\"A method descriptor\"):(this.disallowProperty(o,\"get\",\"The property descriptor of a field descriptor\"),this.disallowProperty(o,\"set\",\"The property descriptor of a field descriptor\"),this.disallowProperty(o,\"value\",\"The property descriptor of a field descriptor\"),i.initializer=e.initializer),i},toElementFinisherExtras:function(e){var t=this.toElementDescriptor(e),r=u(e,\"finisher\"),n=this.toElementDescriptors(e.extras);return{element:t,finisher:r,extras:n}},fromClassDescriptor:function(e){var t={kind:\"class\",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(t,Symbol.toStringTag,{value:\"Descriptor\",configurable:!0}),t},toClassDescriptor:function(e){var t=String(e.kind);if(\"class\"!==t)throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator created a class descriptor with .kind \"'+t+'\"');this.disallowProperty(e,\"key\",\"A class descriptor\"),this.disallowProperty(e,\"placement\",\"A class descriptor\"),this.disallowProperty(e,\"descriptor\",\"A class descriptor\"),this.disallowProperty(e,\"initializer\",\"A class descriptor\"),this.disallowProperty(e,\"extras\",\"A class descriptor\");var r=u(e,\"finisher\"),n=this.toElementDescriptors(e.elements);return{elements:n,finisher:r}},runClassFinishers:function(e,t){for(var r=0;r<t.length;r++){var n=(0,t[r])(e);if(void 0!==n){if(\"function\"!=typeof n)throw new TypeError(\"Finishers must return a constructor.\");e=n}}return e},disallowProperty:function(e,t,r){if(void 0!==e[t])throw new TypeError(r+\" can't have a .\"+t+\" property.\")}};return e}();if(n)for(var i=0;i<n.length;i++)o=n[i](o);var h=t(function(e){o.initializeInstanceElements(e,f.elements)},r),f=o.decorateClass(function(e){for(var t=[],r=function(e){return\"method\"===e.kind&&e.key===i.key&&e.placement===i.placement},n=0;n<e.length;n++){var o,i=e[n];if(\"method\"===i.kind&&(o=t.find(r)))if(l(i.descriptor)||l(o.descriptor)){if(c(i)||c(o))throw new ReferenceError(\"Duplicated methods (\"+i.key+\") can't be decorated.\");o.descriptor=i.descriptor}else{if(c(i)){if(c(o))throw new ReferenceError(\"Decorators can't be placed on different accessors with for the same property (\"+i.key+\").\");o.decorators=i.decorators}s(i,o)}else t.push(i)}return t}(h.d.map(a)),e);o.initializeClassElements(h.F,f.elements),o.runClassFinishers(h.F,f.finishers)}([Object(i.d)(\"ha-code-editor\")],function(e,t){class a extends t{constructor(...t){super(...t),e(this)}}return{F:a,d:[{kind:\"field\",key:\"codemirror\",value:void 0},{kind:\"field\",decorators:[Object(i.g)()],key:\"mode\",value:void 0},{kind:\"field\",decorators:[Object(i.g)()],key:\"autofocus\",value:()=>!1},{kind:\"field\",decorators:[Object(i.g)()],key:\"rtl\",value:()=>!1},{kind:\"field\",decorators:[Object(i.g)()],key:\"error\",value:()=>!1},{kind:\"field\",decorators:[Object(i.g)()],key:\"_value\",value:()=>\"\"},{kind:\"set\",key:\"value\",value:function(e){this._value=e}},{kind:\"get\",key:\"value\",value:function(){return this.codemirror?this.codemirror.getValue():this._value}},{kind:\"get\",key:\"hasComments\",value:function(){return!!this.shadowRoot.querySelector(\"span.cm-comment\")}},{kind:\"method\",key:\"connectedCallback\",value:function(){h(f(a.prototype),\"connectedCallback\",this).call(this),this.codemirror&&(this.codemirror.refresh(),!1!==this.autofocus&&this.codemirror.focus())}},{kind:\"method\",key:\"update\",value:function(e){h(f(a.prototype),\"update\",this).call(this,e),this.codemirror&&(e.has(\"mode\")&&this.codemirror.setOption(\"mode\",this.mode),e.has(\"autofocus\")&&this.codemirror.setOption(\"autofocus\",!1!==this.autofocus),e.has(\"_value\")&&this._value!==this.value&&this.codemirror.setValue(this._value),e.has(\"rtl\")&&(this.codemirror.setOption(\"gutters\",this._calcGutters()),this._setScrollBarDirection()),e.has(\"error\")&&this.classList.toggle(\"error-state\",this.error))}},{kind:\"method\",key:\"firstUpdated\",value:function(e){h(f(a.prototype),\"firstUpdated\",this).call(this,e),this._load()}},{kind:\"method\",key:\"_load\",value:async function(){const e=await(async()=>(n||(n=Promise.all([r.e(121),r.e(27)]).then(r.bind(null,722))),n))(),t=e.codeMirror,o=this.attachShadow({mode:\"open\"});o.innerHTML=`\\n    <style>\\n      ${e.codeMirrorCss}\\n      .CodeMirror {\\n        height: var(--code-mirror-height, auto);\\n        direction: var(--code-mirror-direction, ltr);\\n      }\\n      .CodeMirror-scroll {\\n        max-height: var(--code-mirror-max-height, --code-mirror-height);\\n      }\\n      .CodeMirror-gutters {\\n        border-right: 1px solid var(--paper-input-container-color, var(--secondary-text-color));\\n        background-color: var(--paper-dialog-background-color, var(--primary-background-color));\\n        transition: 0.2s ease border-right;\\n      }\\n      :host(.error-state) .CodeMirror-gutters {\\n        border-color: var(--error-state-color, red);\\n      }\\n      .CodeMirror-focused .CodeMirror-gutters {\\n        border-right: 2px solid var(--paper-input-container-focus-color, var(--primary-color));\\n      }\\n      .CodeMirror-linenumber {\\n        color: var(--paper-dialog-color, var(--primary-text-color));\\n      }\\n      .rtl .CodeMirror-vscrollbar {\\n        right: auto;\\n        left: 0px;\\n      }\\n      .rtl-gutter {\\n        width: 20px;\\n      }\\n    </style>`,this.codemirror=t(o,{value:this._value,lineNumbers:!0,tabSize:2,mode:this.mode,autofocus:!1!==this.autofocus,viewportMargin:1/0,extraKeys:{Tab:\"indentMore\",\"Shift-Tab\":\"indentLess\"},gutters:this._calcGutters()}),this._setScrollBarDirection(),this.codemirror.on(\"changes\",()=>this._onChange())}},{kind:\"method\",key:\"_onChange\",value:function(){const e=this.value;e!==this._value&&(this._value=e,Object(o.a)(this,\"value-changed\",{value:this._value}))}},{kind:\"method\",key:\"_calcGutters\",value:function(){return this.rtl?[\"rtl-gutter\",\"CodeMirror-linenumbers\"]:[]}},{kind:\"method\",key:\"_setScrollBarDirection\",value:function(){this.codemirror&&this.codemirror.getWrapperElement().classList.toggle(\"rtl\",this.rtl)}}]}},i.b)},697:function(e,t,r){\"use strict\";r.r(t);var n=r(0),o=r(70),i=r(267),a=(r(201),r(216),r(146),r(83),r(105),r(183),r(189)),s=(r(176),r(54)),c=(r(238),r(93));function l(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}const u=a.a.interface({title:\"string?\",views:[\"object\"],resources:a.a.optional([\"object\"])});customElements.define(\"hui-editor\",class extends n.a{constructor(...e){super(...e),l(this,\"hass\",void 0),l(this,\"lovelace\",void 0),l(this,\"closeEditor\",void 0),l(this,\"_saving\",void 0),l(this,\"_changed\",void 0),l(this,\"_generation\",1)}static get properties(){return{hass:{},lovelace:{},closeEditor:{},_saving:{},_changed:{}}}render(){return n.f`\n      <app-header-layout>\n        <app-header>\n          <app-toolbar>\n            <paper-icon-button\n              icon=\"hass:close\"\n              @click=\"${this._closeEditor}\"\n            ></paper-icon-button>\n            <div main-title>\n              ${this.hass.localize(\"ui.panel.lovelace.editor.raw_editor.header\")}\n            </div>\n            <div\n              class=\"save-button\n              ${Object(o.a)({saved:!1===this._saving||!0===this._changed})}\"\n            >\n              ${this._changed?this.hass.localize(\"ui.panel.lovelace.editor.raw_editor.unsaved_changes\"):this.hass.localize(\"ui.panel.lovelace.editor.raw_editor.saved\")}\n            </div>\n            <mwc-button raised @click=\"${this._handleSave}\"\n              >${this.hass.localize(\"ui.panel.lovelace.editor.raw_editor.save\")}</mwc-button\n            >\n          </app-toolbar>\n        </app-header>\n        <div class=\"content\">\n          <ha-code-editor\n            mode=\"yaml\"\n            autofocus\n            .rtl=${Object(c.a)(this.hass)}\n            .hass=\"${this.hass}\"\n            @value-changed=\"${this._yamlChanged}\"\n            @editor-save=\"${this._handleSave}\"\n          >\n          </ha-code-editor>\n        </div>\n      </app-header-layout>\n    `}firstUpdated(){this.yamlEditor.value=Object(i.safeDump)(this.lovelace.config)}static get styles(){return[s.a,n.c`\n        :host {\n          --code-mirror-height: 100%;\n        }\n\n        app-header-layout {\n          height: 100vh;\n        }\n\n        app-toolbar {\n          background-color: var(--dark-background-color, #455a64);\n          color: var(--dark-text-color);\n        }\n\n        .comments {\n          font-size: 16px;\n        }\n\n        .content {\n          height: calc(100vh - 68px);\n        }\n\n        hui-code-editor {\n          height: 100%;\n        }\n\n        .save-button {\n          opacity: 0;\n          font-size: 14px;\n          padding: 0px 10px;\n        }\n\n        .saved {\n          opacity: 1;\n        }\n      `]}_yamlChanged(){this._changed=!this.yamlEditor.codemirror.getDoc().isClean(this._generation),this._changed&&!window.onbeforeunload?window.onbeforeunload=(()=>!0):!this._changed&&window.onbeforeunload&&(window.onbeforeunload=null)}_closeEditor(){this._changed&&!confirm(this.hass.localize(\"ui.panel.lovelace.editor.raw_editor.confirm_unsaved_changes\"))||(window.onbeforeunload=null,this.closeEditor&&this.closeEditor())}async _handleSave(){if(this._saving=!0,this.yamlEditor.hasComments&&!confirm(this.hass.localize(\"ui.panel.lovelace.editor.raw_editor.confirm_unsaved_comments\")))return;let e;try{e=Object(i.safeLoad)(this.yamlEditor.value)}catch(t){return alert(this.hass.localize(\"ui.panel.lovelace.editor.raw_editor.error_parse_yaml\",\"error\",t)),void(this._saving=!1)}try{e=u(e)}catch(t){return void alert(this.hass.localize(\"ui.panel.lovelace.editor.raw_editor.error_invalid_config\",\"error\",t))}try{await this.lovelace.saveConfig(e)}catch(t){alert(this.hass.localize(\"ui.panel.lovelace.editor.raw_editor.error_save_yaml\",\"error\",t))}this._generation=this.yamlEditor.codemirror.getDoc().changeGeneration(!0),window.onbeforeunload=null,this._saving=!1,this._changed=!1}get yamlEditor(){return this.shadowRoot.querySelector(\"ha-code-editor\")}})}}]);","extractedComments":[]}