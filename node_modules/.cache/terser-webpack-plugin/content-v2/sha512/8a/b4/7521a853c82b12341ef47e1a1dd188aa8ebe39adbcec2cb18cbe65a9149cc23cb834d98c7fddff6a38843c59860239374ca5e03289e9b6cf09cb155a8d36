{"map":"{\"version\":3,\"sources\":[\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/panels/lovelace/common/structs/struct.ts\",\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/panels/lovelace/common/structs/is-entity-id.ts\",\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/panels/lovelace/common/structs/is-icon.ts\",\"../src/error.js\",\"../node_modules/kind-of/index.js\",\"../src/constants.js\",\"../src/utils.js\",\"../src/kinds.js\",\"../src/types.js\",\"../src/superstruct.js\",\"../src/index.js\",\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/panels/lovelace/editor/config-elements/config-elements-style.ts\",\"/home/sandya/Sandya/workspace/Brandon/home-assistant-polymer/src/panels/lovelace/editor/config-elements/hui-iframe-card-editor.ts\"],\"names\":[\"__webpack_require__\",\"d\",\"__webpack_exports__\",\"struct\",\"superstruct\",\"types\",\"entity-id\",\"value\",\"includes\",\"icon\",\"StructError\",\"TypeError\",\"attrs\",\"type\",\"path\",\"JSON\",\"data\",\"reason\",\"errors\",\"length\",\"push\",\"this\",\"Error\",\"captureStackTrace\",\"constructor\",\"stack\",\"toString\",\"Object\",\"prototype\",\"kindOf\",\"val\",\"ctorName\",\"Array\",\"isArray\",\"isBuffer\",\"callee\",\"err\",\"message\",\"indexOf\",\"isArguments\",\"Date\",\"toDateString\",\"getDate\",\"setDate\",\"isDate\",\"stackTraceLimit\",\"isError\",\"RegExp\",\"flags\",\"ignoreCase\",\"multiline\",\"global\",\"isRegexp\",\"throw\",\"return\",\"next\",\"isGeneratorObj\",\"call\",\"slice\",\"toLowerCase\",\"replace\",\"name\",\"IS_STRUCT\",\"KIND\",\"isStruct\",\"resolveDefaults\",\"defaults\",\"Kind\",\"validate\",\"any\",\"schema\",\"defaults$$1\",\"options\",\"tuple\",\"list\",\"func\",\"object\",\"required\",\"union\",\"intersection\",\"scalar\",\"optional\",\"en\",\"map\",\"s\",\"e\",\"String\",\"join\",\"undefined\",\"result\",\"isValid\",\"failure\",\"_extends\",\"array\",\"element\",\"error\",\"ret\",\"i\",\"v\",\"r\",\"forEach\",\"singleE\",\"concat\",\"first\",\"obj\",\"ks\",\"properties\",\"key\",\"kind\",\"valueKeys\",\"propertiesKeys\",\"Set\",\"fn\",\"kinds\",\"k\",\"Math\",\"t\",\"Kinds\",\"dict\",\"keys\",\"values\",\"resolved\",\"e2\",\"r2\",\"enums\",\"instance\",\"lazy\",\"literal\",\"partial\",\"createSchema\",\"Types\",\"config\",\"Struct\",\"defineProperty\",\"assert\",\"test\",\"TYPES\",\"isNaN\",\"configElementStyle\",\"html\",\"cardConfigStruct\",\"title\",\"url\",\"aspect_ratio\",\"HuiIframeCardEditor\",\"_decorate\",\"customElement\",\"_initialize\",\"_LitElement\",\"F\",\"[object Object]\",\"args\",\"super\",\"decorators\",\"property\",\"_config\",\"hass\",\"localize\",\"_url\",\"_valueChanged\",\"_title\",\"Number\",\"_aspect_ratio\",\"ev\",\"target\",\"configValue\",\"assign\",\"fireEvent\",\"LitElement\"],\"mappings\":\"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\",\"sourcesContent\":[\"import { superstruct } from \\\"superstruct\\\";\\nimport { isEntityId } from \\\"./is-entity-id\\\";\\nimport { isIcon } from \\\"./is-icon\\\";\\n\\nexport const struct = superstruct({\\n  types: {\\n    \\\"entity-id\\\": isEntityId,\\n    icon: isIcon,\\n  },\\n});\\n\",\"export function isEntityId(value: any): string | boolean {\\n  if (typeof value !== \\\"string\\\") {\\n    return \\\"entity id should be a string\\\";\\n  }\\n  if (!value.includes(\\\".\\\")) {\\n    return \\\"entity id should be in the format 'domain.entity'\\\";\\n  }\\n  return true;\\n}\\n\",\"export function isIcon(value: any): string | boolean {\\n  if (typeof value !== \\\"string\\\") {\\n    return \\\"icon should be a string\\\";\\n  }\\n  if (!value.includes(\\\":\\\")) {\\n    return \\\"icon should be in the format 'mdi:icon'\\\";\\n  }\\n  return true;\\n}\\n\",\"/**\\n * Define a struct error.\\n *\\n * @type {StructError}\\n */\\n\\nclass StructError extends TypeError {\\n  static format(attrs) {\\n    const { type, path, value } = attrs\\n    const message = `Expected a value of type \\\\`${type}\\\\`${\\n      path.length ? ` for \\\\`${path.join('.')}\\\\`` : ''\\n    } but received \\\\`${JSON.stringify(value)}\\\\`.`\\n    return message\\n  }\\n\\n  constructor(attrs) {\\n    const message = StructError.format(attrs)\\n    super(message)\\n\\n    const { data, path, value, reason, type, errors = [] } = attrs\\n    this.data = data\\n    this.path = path\\n    this.value = value\\n    this.reason = reason\\n    this.type = type\\n    this.errors = errors\\n\\n    if (!errors.length) {\\n      errors.push(this)\\n    }\\n\\n    if (Error.captureStackTrace) {\\n      Error.captureStackTrace(this, this.constructor)\\n    } else {\\n      this.stack = new Error().stack\\n    }\\n  }\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {StructError}\\n */\\n\\nexport default StructError\\n\",\"var toString = Object.prototype.toString;\\n\\nmodule.exports = function kindOf(val) {\\n  if (val === void 0) return 'undefined';\\n  if (val === null) return 'null';\\n\\n  var type = typeof val;\\n  if (type === 'boolean') return 'boolean';\\n  if (type === 'string') return 'string';\\n  if (type === 'number') return 'number';\\n  if (type === 'symbol') return 'symbol';\\n  if (type === 'function') {\\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\\n  }\\n\\n  if (isArray(val)) return 'array';\\n  if (isBuffer(val)) return 'buffer';\\n  if (isArguments(val)) return 'arguments';\\n  if (isDate(val)) return 'date';\\n  if (isError(val)) return 'error';\\n  if (isRegexp(val)) return 'regexp';\\n\\n  switch (ctorName(val)) {\\n    case 'Symbol': return 'symbol';\\n    case 'Promise': return 'promise';\\n\\n    // Set, Map, WeakSet, WeakMap\\n    case 'WeakMap': return 'weakmap';\\n    case 'WeakSet': return 'weakset';\\n    case 'Map': return 'map';\\n    case 'Set': return 'set';\\n\\n    // 8-bit typed arrays\\n    case 'Int8Array': return 'int8array';\\n    case 'Uint8Array': return 'uint8array';\\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\\n\\n    // 16-bit typed arrays\\n    case 'Int16Array': return 'int16array';\\n    case 'Uint16Array': return 'uint16array';\\n\\n    // 32-bit typed arrays\\n    case 'Int32Array': return 'int32array';\\n    case 'Uint32Array': return 'uint32array';\\n    case 'Float32Array': return 'float32array';\\n    case 'Float64Array': return 'float64array';\\n  }\\n\\n  if (isGeneratorObj(val)) {\\n    return 'generator';\\n  }\\n\\n  // Non-plain objects\\n  type = toString.call(val);\\n  switch (type) {\\n    case '[object Object]': return 'object';\\n    // iterators\\n    case '[object Map Iterator]': return 'mapiterator';\\n    case '[object Set Iterator]': return 'setiterator';\\n    case '[object String Iterator]': return 'stringiterator';\\n    case '[object Array Iterator]': return 'arrayiterator';\\n  }\\n\\n  // other\\n  return type.slice(8, -1).toLowerCase().replace(/\\\\s/g, '');\\n};\\n\\nfunction ctorName(val) {\\n  return val.constructor ? val.constructor.name : null;\\n}\\n\\nfunction isArray(val) {\\n  if (Array.isArray) return Array.isArray(val);\\n  return val instanceof Array;\\n}\\n\\nfunction isError(val) {\\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\\n}\\n\\nfunction isDate(val) {\\n  if (val instanceof Date) return true;\\n  return typeof val.toDateString === 'function'\\n    && typeof val.getDate === 'function'\\n    && typeof val.setDate === 'function';\\n}\\n\\nfunction isRegexp(val) {\\n  if (val instanceof RegExp) return true;\\n  return typeof val.flags === 'string'\\n    && typeof val.ignoreCase === 'boolean'\\n    && typeof val.multiline === 'boolean'\\n    && typeof val.global === 'boolean';\\n}\\n\\nfunction isGeneratorFn(name, val) {\\n  return ctorName(name) === 'GeneratorFunction';\\n}\\n\\nfunction isGeneratorObj(val) {\\n  return typeof val.throw === 'function'\\n    && typeof val.return === 'function'\\n    && typeof val.next === 'function';\\n}\\n\\nfunction isArguments(val) {\\n  try {\\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\\n      return true;\\n    }\\n  } catch (err) {\\n    if (err.message.indexOf('callee') !== -1) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\n/**\\n * If you need to support Safari 5-7 (8-10 yr-old browser),\\n * take a look at https://github.com/feross/is-buffer\\n */\\n\\nfunction isBuffer(val) {\\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\\n    return val.constructor.isBuffer(val);\\n  }\\n  return false;\\n}\\n\",\"/**\\n * A private string to identify structs by.\\n *\\n * @type {String}\\n */\\n\\nconst IS_STRUCT = '@@__STRUCT__@@'\\n\\n/**\\n * A private string to refer to a struct's kind.\\n *\\n * @type {String}\\n */\\n\\nconst KIND = '@@__KIND__@@'\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nexport { IS_STRUCT, KIND }\\n\",\"import { IS_STRUCT } from './constants'\\n\\n/**\\n * Check if a `value` is a struct.\\n *\\n * @param {Any} value\\n * @return {Boolean}\\n */\\n\\nexport function isStruct(value) {\\n  return !!(value && value[IS_STRUCT])\\n}\\n\\n/**\\n * Resolve `defaults`, for an optional `value`.\\n *\\n * @param {Function|Any} defaults\\n * @param {Any} value\\n * @return {Any}\\n */\\n\\nexport function resolveDefaults(defaults, value) {\\n  return typeof defaults === 'function' ? defaults(value) : defaults\\n}\\n\",\"import kindOf from 'kind-of'\\n\\nimport { KIND } from './constants'\\nimport { isStruct, resolveDefaults } from './utils'\\n\\n/**\\n * Kind.\\n *\\n * @type {Kind}\\n */\\n\\nclass Kind {\\n  constructor(name, type, validate) {\\n    this.name = name\\n    this.type = type\\n    this.validate = validate\\n  }\\n}\\n\\n/**\\n * Any.\\n *\\n * @param {Array|Function|Object|String} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction any(schema, defaults, options) {\\n  if (isStruct(schema)) {\\n    return schema[KIND]\\n  }\\n\\n  if (schema instanceof Kind) {\\n    return schema\\n  }\\n\\n  switch (kindOf(schema)) {\\n    case 'array': {\\n      return schema.length > 1\\n        ? tuple(schema, defaults, options)\\n        : list(schema, defaults, options)\\n    }\\n\\n    case 'function': {\\n      return func(schema, defaults, options)\\n    }\\n\\n    case 'object': {\\n      return object(schema, defaults, options)\\n    }\\n\\n    case 'string': {\\n      let required = true\\n      let type\\n\\n      if (schema.endsWith('?')) {\\n        required = false\\n        schema = schema.slice(0, -1)\\n      }\\n\\n      if (schema.includes('|')) {\\n        const scalars = schema.split(/\\\\s*\\\\|\\\\s*/g)\\n        type = union(scalars, defaults, options)\\n      } else if (schema.includes('&')) {\\n        const scalars = schema.split(/\\\\s*&\\\\s*/g)\\n        type = intersection(scalars, defaults, options)\\n      } else {\\n        type = scalar(schema, defaults, options)\\n      }\\n\\n      if (!required) {\\n        type = optional(type, undefined, options)\\n      }\\n\\n      return type\\n    }\\n  }\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    throw new Error(\\n      `A schema definition must be an object, array, string or function, but you passed: ${schema}`\\n    )\\n  } else {\\n    throw new Error(`Invalid schema: ${schema}`)\\n  }\\n}\\n\\n/**\\n * Dict.\\n *\\n * @param {Array} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction dict(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array' || schema.length !== 2) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Dict structs must be defined as an array with two elements, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const obj = scalar('object', undefined, options)\\n  const keys = any(schema[0], undefined, options)\\n  const values = any(schema[1], undefined, options)\\n  const name = 'dict'\\n  const type = `dict<${keys.type},${values.type}>`\\n  const validate = value => {\\n    const resolved = resolveDefaults(defaults)\\n    value = resolved ? { ...resolved, ...value } : value\\n    const [error] = obj.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const ret = {}\\n    const errors = []\\n\\n    for (let k in value) {\\n      const v = value[k]\\n      const [e, r] = keys.validate(k)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [k].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      k = r\\n      const [e2, r2] = values.validate(v)\\n\\n      if (e2) {\\n        const allE2 = e2.errors || [e2]\\n        allE2.forEach(singleE => {\\n          singleE.path = [k].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      ret[k] = r2\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Enum.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction en(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Enum structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const name = 'enum'\\n  const type = schema\\n    .map(s => {\\n      try {\\n        return JSON.stringify(s)\\n      } catch (e) {\\n        return String(s)\\n      }\\n    })\\n    .join(' | ')\\n\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    return schema.includes(value)\\n      ? [undefined, value]\\n      : [{ data: value, path: [], value, type }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Enums.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction enums(schema, defaults, options) {\\n  const e = en(schema, undefined, options)\\n  const l = list([e], defaults, options)\\n  return l\\n}\\n\\n/**\\n * Function.\\n *\\n * @param {Function} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction func(schema, defaults, options) {\\n  if (kindOf(schema) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Function structs must be defined as a function, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const name = 'function'\\n  const type = '<function>'\\n  const validate = (value = resolveDefaults(defaults), data) => {\\n    const result = schema(value, data)\\n    let failure = { path: [], reason: null }\\n    let isValid\\n\\n    switch (kindOf(result)) {\\n      case 'boolean': {\\n        isValid = result\\n        break\\n      }\\n      case 'string': {\\n        isValid = false\\n        failure.reason = result\\n        break\\n      }\\n      case 'object': {\\n        isValid = false\\n        failure = { ...failure, ...result }\\n        break\\n      }\\n      default: {\\n        if (process.env.NODE_ENV !== 'production') {\\n          throw new Error(\\n            `Validator functions must return a boolean, an error reason string or an error reason object, but you passed: ${schema}`\\n          )\\n        } else {\\n          throw new Error(`Invalid result: ${result}`)\\n        }\\n      }\\n    }\\n\\n    return isValid\\n      ? [undefined, value]\\n      : [{ type, value, data: value, ...failure }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Instance.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction instance(schema, defaults, options) {\\n  const name = 'instance'\\n  const type = `instance<${schema.name}>`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    return value instanceof schema\\n      ? [undefined, value]\\n      : [{ data: value, path: [], value, type }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Interface.\\n *\\n * @param {Object} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction inter(schema, defaults, options) {\\n  if (kindOf(schema) !== 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Interface structs must be defined as an object, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const ks = []\\n  const properties = {}\\n\\n  for (const key in schema) {\\n    ks.push(key)\\n    const s = schema[key]\\n    const kind = any(s, undefined, options)\\n    properties[key] = kind\\n  }\\n\\n  const name = 'interface'\\n  const type = `{${ks.join()}}`\\n  const validate = value => {\\n    const resolved = resolveDefaults(defaults)\\n    value = resolved ? { ...resolved, ...value } : value\\n    const errors = []\\n    const ret = value\\n\\n    for (const key in properties) {\\n      let v = value[key]\\n      const kind = properties[key]\\n\\n      if (v === undefined) {\\n        const d = defaults && defaults[key]\\n        v = resolveDefaults(d, value)\\n      }\\n\\n      const [e, r] = kind.validate(v, value)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [key].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      if (key in value || r !== undefined) {\\n        ret[key] = r\\n      }\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Lazy.\\n *\\n * @param {Function} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction lazy(schema, defaults, options) {\\n  if (kindOf(schema) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Lazy structs must be defined as an function that returns a schema, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  let kind\\n  let struct\\n  const name = 'lazy'\\n  const type = `lazy...`\\n  const compile = value => {\\n    struct = schema()\\n    kind.name = struct.kind\\n    kind.type = struct.type\\n    kind.validate = struct.validate\\n    return kind.validate(value)\\n  }\\n\\n  kind = new Kind(name, type, compile)\\n  return kind\\n}\\n\\n/**\\n * Dynamic.\\n *\\n * @param {Function} createSchema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction dynamic(createSchema, defaults, options) {\\n  if (kindOf(createSchema) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Dynamic structs must be defined as a function, but you passed: ${createSchema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${createSchema}`)\\n    }\\n  }\\n\\n  const name = 'dynamic'\\n  const type = 'dynamic...'\\n  const validate = (value = resolveDefaults(defaults), data) => {\\n    const schema = createSchema(value, data)\\n\\n    if (kindOf(schema) !== 'function') {\\n      if (process.env.NODE_ENV !== 'production') {\\n        throw new Error(\\n          `Dynamic structs must return a schema, but you passed: ${schema}`\\n        )\\n      } else {\\n        throw new Error(`Invalid schema: ${schema}`)\\n      }\\n    }\\n\\n    const [error, result] = schema.validate(value)\\n\\n    if (error) {\\n      return [error]\\n    }\\n\\n    return [undefined, result]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * List.\\n *\\n * @param {Array} schema\\n * @param {Array} defaults\\n * @param {Object} options\\n */\\n\\nfunction list(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array' || schema.length !== 1) {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `List structs must be defined as an array with a single element, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const array = scalar('array', undefined, options)\\n  const element = any(schema[0], undefined, options)\\n  const name = 'list'\\n  const type = `[${element.type}]`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error, result] = array.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    value = result\\n    const errors = []\\n    const ret = []\\n\\n    for (let i = 0; i < value.length; i++) {\\n      const v = value[i]\\n      const [e, r] = element.validate(v)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [i].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      ret[i] = r\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Literal.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction literal(schema, defaults, options) {\\n  const name = 'literal'\\n  const type = `literal: ${JSON.stringify(schema)}`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    return value === schema\\n      ? [undefined, value]\\n      : [{ data: value, path: [], value, type }]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Object.\\n *\\n * @param {Object} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction object(schema, defaults, options) {\\n  if (kindOf(schema) !== 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Object structs must be defined as an object, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const obj = scalar('object', undefined, options)\\n  const ks = []\\n  const properties = {}\\n\\n  for (const key in schema) {\\n    ks.push(key)\\n    const s = schema[key]\\n    const kind = any(s, undefined, options)\\n    properties[key] = kind\\n  }\\n\\n  const name = 'object'\\n  const type = `{${ks.join()}}`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error] = obj.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const errors = []\\n    const ret = {}\\n    const valueKeys = Object.keys(value)\\n    const propertiesKeys = Object.keys(properties)\\n    const keys = new Set(valueKeys.concat(propertiesKeys))\\n\\n    keys.forEach(key => {\\n      let v = value[key]\\n      const kind = properties[key]\\n\\n      if (v === undefined) {\\n        const d = defaults && defaults[key]\\n        v = resolveDefaults(d, value)\\n      }\\n\\n      if (!kind) {\\n        const e = { data: value, path: [key], value: v }\\n        errors.push(e)\\n        return\\n      }\\n\\n      const [e, r] = kind.validate(v, value)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [key].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        return\\n      }\\n\\n      if (key in value || r !== undefined) {\\n        ret[key] = r\\n      }\\n    })\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Optional.\\n *\\n * @param {Any} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction optional(schema, defaults, options) {\\n  return union([schema, 'undefined'], defaults, options)\\n}\\n\\n/**\\n * Partial.\\n *\\n * @param {Object} schema\\n * @param {Object} defaults\\n * @param {Object} options\\n */\\n\\nfunction partial(schema, defaults, options) {\\n  if (kindOf(schema) !== 'object') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Partial structs must be defined as an object, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const obj = scalar('object', undefined, options)\\n  const ks = []\\n  const properties = {}\\n\\n  for (const key in schema) {\\n    ks.push(key)\\n    const s = schema[key]\\n    const kind = any(s, undefined, options)\\n    properties[key] = kind\\n  }\\n\\n  const name = 'partial'\\n  const type = `{${ks.join()},...}`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error] = obj.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const errors = []\\n    const ret = {}\\n\\n    for (const key in properties) {\\n      let v = value[key]\\n      const kind = properties[key]\\n\\n      if (v === undefined) {\\n        const d = defaults && defaults[key]\\n        v = resolveDefaults(d, value)\\n      }\\n\\n      const [e, r] = kind.validate(v, value)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [key].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      if (key in value || r !== undefined) {\\n        ret[key] = r\\n      }\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Scalar.\\n *\\n * @param {String} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction scalar(schema, defaults, options) {\\n  if (kindOf(schema) !== 'string') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Scalar structs must be defined as a string, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const { types } = options\\n  const fn = types[schema]\\n\\n  if (kindOf(fn) !== 'function') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `No struct validator function found for type \\\"${schema}\\\".`\\n      )\\n    } else {\\n      throw new Error(`Invalid type: ${schema}`)\\n    }\\n  }\\n\\n  const kind = func(fn, defaults, options)\\n  const name = 'scalar'\\n  const type = schema\\n  const validate = value => {\\n    const [error, result] = kind.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    return [undefined, result]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Tuple.\\n *\\n * @param {Array} schema\\n * @param {Array} defaults\\n * @param {Object} options\\n */\\n\\nfunction tuple(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Tuple structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const kinds = schema.map(s => any(s, undefined, options))\\n  const array = scalar('array', undefined, options)\\n  const name = 'tuple'\\n  const type = `[${kinds.map(k => k.type).join()}]`\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const [error] = array.validate(value)\\n\\n    if (error) {\\n      error.type = type\\n      return [error]\\n    }\\n\\n    const ret = []\\n    const errors = []\\n    const length = Math.max(value.length, kinds.length)\\n\\n    for (let i = 0; i < length; i++) {\\n      const kind = kinds[i]\\n      const v = value[i]\\n\\n      if (!kind) {\\n        const e = { data: value, path: [i], value: v }\\n        errors.push(e)\\n        continue\\n      }\\n\\n      const [e, r] = kind.validate(v)\\n\\n      if (e) {\\n        const allE = e.errors || [e]\\n        allE.forEach(singleE => {\\n          singleE.path = [i].concat(singleE.path)\\n          singleE.data = value\\n          errors.push(singleE)\\n        })\\n        continue\\n      }\\n\\n      ret[i] = r\\n    }\\n\\n    if (errors.length) {\\n      const first = errors[0]\\n      first.errors = errors\\n      return [first]\\n    }\\n\\n    return [undefined, ret]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Union.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction union(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Union structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const kinds = schema.map(s => any(s, undefined, options))\\n  const name = 'union'\\n  const type = kinds.map(k => k.type).join(' | ')\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    const errors = []\\n\\n    for (const k of kinds) {\\n      const [e, r] = k.validate(value)\\n\\n      if (!e) {\\n        return [undefined, r]\\n      }\\n\\n      errors.push(e)\\n    }\\n    errors[0].type = type\\n    return errors\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Intersection.\\n *\\n * @param {Array} schema\\n * @param {Any} defaults\\n * @param {Object} options\\n */\\n\\nfunction intersection(schema, defaults, options) {\\n  if (kindOf(schema) !== 'array') {\\n    if (process.env.NODE_ENV !== 'production') {\\n      throw new Error(\\n        `Intersection structs must be defined as an array, but you passed: ${schema}`\\n      )\\n    } else {\\n      throw new Error(`Invalid schema: ${schema}`)\\n    }\\n  }\\n\\n  const types = schema.map(s => any(s, undefined, options))\\n  const name = 'intersection'\\n  const type = types.map(t => t.type).join(' & ')\\n  const validate = (value = resolveDefaults(defaults)) => {\\n    let v = value\\n\\n    for (const t of types) {\\n      const [e, r] = t.validate(v)\\n\\n      if (e) {\\n        e.type = type\\n        return [e]\\n      }\\n\\n      v = r\\n    }\\n\\n    return [undefined, v]\\n  }\\n\\n  return new Kind(name, type, validate)\\n}\\n\\n/**\\n * Kinds.\\n *\\n * @type {Object}\\n */\\n\\nconst Kinds = {\\n  any,\\n  dict,\\n  enum: en,\\n  enums,\\n  function: func,\\n  instance,\\n  interface: inter,\\n  lazy,\\n  list,\\n  literal,\\n  object,\\n  optional,\\n  partial,\\n  scalar,\\n  tuple,\\n  union,\\n  intersection,\\n  dynamic,\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nexport default Kinds\\n\",\"import kindOf from 'kind-of'\\n\\n/**\\n * The types that `kind-of` supports.\\n *\\n * @type {Array}\\n */\\n\\nconst TYPES = [\\n  'arguments',\\n  'array',\\n  'boolean',\\n  'buffer',\\n  'error',\\n  'float32array',\\n  'float64array',\\n  'function',\\n  'generatorfunction',\\n  'int16array',\\n  'int32array',\\n  'int8array',\\n  'map',\\n  'null',\\n  'number',\\n  'object',\\n  'promise',\\n  'regexp',\\n  'set',\\n  'string',\\n  'symbol',\\n  'uint16array',\\n  'uint32array',\\n  'uint8array',\\n  'uint8clampedarray',\\n  'undefined',\\n  'weakmap',\\n  'weakset',\\n]\\n\\n/**\\n * The default types that Superstruct ships with.\\n *\\n * @type {Object}\\n */\\n\\nconst Types = {\\n  any: value => value !== undefined,\\n}\\n\\nTYPES.forEach(type => {\\n  Types[type] = value => kindOf(value) === type\\n})\\n\\n/**\\n * Handle the 'date' case specially, to throw out invalid `Date` objects.\\n *\\n * @param {Mixed} value\\n * @return {Boolean}\\n */\\n\\nTypes.date = value => kindOf(value) === 'date' && !isNaN(value)\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nexport default Types\\n\",\"import Kinds from './kinds'\\nimport StructError from './error'\\nimport Types from './types'\\nimport { isStruct } from './utils'\\nimport { IS_STRUCT, KIND } from './constants'\\n\\n/**\\n * Create a struct factory with a `config`.\\n *\\n * @param {Object} config\\n * @return {Function}\\n */\\n\\nfunction superstruct(config = {}) {\\n  const types = {\\n    ...Types,\\n    ...(config.types || {}),\\n  }\\n\\n  /**\\n   * Create a `kind` struct with `schema`, `defaults` and `options`.\\n   *\\n   * @param {Any} schema\\n   * @param {Any} defaults\\n   * @param {Object} options\\n   * @return {Function}\\n   */\\n\\n  function struct(schema, defaults, options = {}) {\\n    if (isStruct(schema)) {\\n      schema = schema.schema\\n    }\\n\\n    const kind = Kinds.any(schema, defaults, { ...options, types })\\n\\n    function Struct(data) {\\n      if (this instanceof Struct) {\\n        if (process.env.NODE_ENV !== 'production') {\\n          throw new Error(\\n            'The `Struct` creation function should not be used with the `new` keyword.'\\n          )\\n        } else {\\n          throw new Error('Invalid `new` keyword!')\\n        }\\n      }\\n\\n      return Struct.assert(data)\\n    }\\n\\n    Object.defineProperty(Struct, IS_STRUCT, { value: true })\\n    Object.defineProperty(Struct, KIND, { value: kind })\\n\\n    Struct.kind = kind.name\\n    Struct.type = kind.type\\n    Struct.schema = schema\\n    Struct.defaults = defaults\\n    Struct.options = options\\n\\n    Struct.assert = value => {\\n      const [error, result] = kind.validate(value)\\n\\n      if (error) {\\n        throw new StructError(error)\\n      }\\n\\n      return result\\n    }\\n\\n    Struct.test = value => {\\n      const [error] = kind.validate(value)\\n      return !error\\n    }\\n\\n    Struct.validate = value => {\\n      const [error, result] = kind.validate(value)\\n\\n      if (error) {\\n        return [new StructError(error)]\\n      }\\n\\n      return [undefined, result]\\n    }\\n\\n    return Struct\\n  }\\n\\n  /**\\n   * Mix in a factory for each specific kind of struct.\\n   */\\n\\n  Object.keys(Kinds).forEach(name => {\\n    const kind = Kinds[name]\\n\\n    struct[name] = (schema, defaults, options) => {\\n      const type = kind(schema, defaults, { ...options, types })\\n      const s = struct(type, defaults, options)\\n      return s\\n    }\\n  })\\n\\n  /**\\n   * Return the struct factory.\\n   */\\n\\n  return struct\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {Function}\\n */\\n\\nexport default superstruct\\n\",\"import StructError from './error'\\nimport superstruct from './superstruct'\\nimport { isStruct } from './utils'\\n\\n/**\\n * Create a convenience `struct` factory for the default types.\\n *\\n * @type {Function}\\n */\\n\\nconst struct = superstruct()\\n\\n/**\\n * Export.\\n *\\n * @type {Function}\\n */\\n\\nexport { struct, superstruct, isStruct, StructError }\\n\",\"import { html } from \\\"lit-element\\\";\\n\\nexport const configElementStyle = html`\\n  <style>\\n    ha-switch {\\n      padding: 16px 0;\\n    }\\n    .side-by-side {\\n      display: flex;\\n    }\\n    .side-by-side > * {\\n      flex: 1;\\n      padding-right: 4px;\\n    }\\n    .suffix {\\n      margin: 0 8px;\\n    }\\n  </style>\\n`;\\n\",\"import {\\n  html,\\n  LitElement,\\n  TemplateResult,\\n  customElement,\\n  property,\\n} from \\\"lit-element\\\";\\nimport \\\"@polymer/paper-input/paper-input\\\";\\n\\nimport { struct } from \\\"../../common/structs/struct\\\";\\nimport { EntitiesEditorEvent, EditorTarget } from \\\"../types\\\";\\nimport { HomeAssistant } from \\\"../../../../types\\\";\\nimport { LovelaceCardEditor } from \\\"../../types\\\";\\nimport { fireEvent } from \\\"../../../../common/dom/fire_event\\\";\\nimport { configElementStyle } from \\\"./config-elements-style\\\";\\nimport { IframeCardConfig } from \\\"../../cards/types\\\";\\n\\nconst cardConfigStruct = struct({\\n  type: \\\"string\\\",\\n  title: \\\"string?\\\",\\n  url: \\\"string?\\\",\\n  aspect_ratio: \\\"string?\\\",\\n});\\n\\n@customElement(\\\"hui-iframe-card-editor\\\")\\nexport class HuiIframeCardEditor extends LitElement\\n  implements LovelaceCardEditor {\\n  @property() public hass?: HomeAssistant;\\n\\n  @property() private _config?: IframeCardConfig;\\n\\n  public setConfig(config: IframeCardConfig): void {\\n    config = cardConfigStruct(config);\\n    this._config = config;\\n  }\\n\\n  get _title(): string {\\n    return this._config!.title || \\\"\\\";\\n  }\\n\\n  get _url(): string {\\n    return this._config!.url || \\\"\\\";\\n  }\\n\\n  get _aspect_ratio(): string {\\n    return this._config!.aspect_ratio || \\\"\\\";\\n  }\\n\\n  protected render(): TemplateResult | void {\\n    if (!this.hass) {\\n      return html``;\\n    }\\n\\n    return html`\\n      ${configElementStyle}\\n      <div class=\\\"card-config\\\">\\n        <paper-input\\n          .label=\\\"${this.hass.localize(\\n            \\\"ui.panel.lovelace.editor.card.generic.url\\\"\\n          )} (${this.hass.localize(\\n            \\\"ui.panel.lovelace.editor.card.config.required\\\"\\n          )})\\\"\\n          .value=\\\"${this._url}\\\"\\n          .configValue=\\\"${\\\"url\\\"}\\\"\\n          @value-changed=\\\"${this._valueChanged}\\\"\\n        ></paper-input>\\n        <div class=\\\"side-by-side\\\">\\n          <paper-input\\n            .label=\\\"${this.hass.localize(\\n              \\\"ui.panel.lovelace.editor.card.generic.title\\\"\\n            )} (${this.hass.localize(\\n              \\\"ui.panel.lovelace.editor.card.config.optional\\\"\\n            )})\\\"\\n            .value=\\\"${this._title}\\\"\\n            .configValue=\\\"${\\\"title\\\"}\\\"\\n            @value-changed=\\\"${this._valueChanged}\\\"\\n          ></paper-input>\\n          <paper-input\\n            .label=\\\"${this.hass.localize(\\n              \\\"ui.panel.lovelace.editor.card.generic.aspect_ratio\\\"\\n            )} (${this.hass.localize(\\n              \\\"ui.panel.lovelace.editor.card.config.optional\\\"\\n            )})\\\"\\n            type=\\\"number\\\"\\n            .value=\\\"${Number(this._aspect_ratio.replace(\\\"%\\\", \\\"\\\"))}\\\"\\n            .configValue=\\\"${\\\"aspect_ratio\\\"}\\\"\\n            @value-changed=\\\"${this._valueChanged}\\\"\\n          ></paper-input>\\n        </div>\\n      </div>\\n    `;\\n  }\\n\\n  private _valueChanged(ev: EntitiesEditorEvent): void {\\n    if (!this._config || !this.hass) {\\n      return;\\n    }\\n    const target = ev.target! as EditorTarget;\\n    let value = target.value;\\n\\n    if (target.configValue! === \\\"aspect_ratio\\\" && target.value) {\\n      value += \\\"%\\\";\\n    }\\n\\n    if (this[`_${target.configValue}`] === value) {\\n      return;\\n    }\\n    if (target.configValue) {\\n      if (target.value === \\\"\\\") {\\n        delete this._config[target.configValue!];\\n      } else {\\n        this._config = { ...this._config, [target.configValue!]: value };\\n      }\\n    }\\n    fireEvent(this, \\\"config-changed\\\", { config: this._config });\\n  }\\n}\\n\\ndeclare global {\\n  interface HTMLElementTagNameMap {\\n    \\\"hui-iframe-card-editor\\\": HuiIframeCardEditor;\\n  }\\n}\\n\"]}","code":"(self.webpackJsonp=self.webpackJsonp||[]).push([[61],{189:function(e,t,r){\"use strict\";var n=r(200);r.d(t,\"a\",function(){return i});const i=Object(n.a)({types:{\"entity-id\":function(e){return\"string\"!=typeof e?\"entity id should be a string\":!!e.includes(\".\")||\"entity id should be in the format 'domain.entity'\"},icon:function(e){return\"string\"!=typeof e?\"icon should be a string\":!!e.includes(\":\")||\"icon should be in the format 'mdi:icon'\"}}})},200:function(e,t,r){\"use strict\";r.d(t,\"a\",function(){return _});class n extends TypeError{static format(e){const{type:t,path:r,value:n}=e;return`Expected a value of type \\`${t}\\`${r.length?` for \\`${r.join(\".\")}\\``:\"\"} but received \\`${JSON.stringify(n)}\\`.`}constructor(e){super(n.format(e));const{data:t,path:r,value:i,reason:o,type:a,errors:s=[]}=e;this.data=t,this.path=r,this.value=i,this.reason=o,this.type=a,this.errors=s,s.length||s.push(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack}}var i=Object.prototype.toString,o=function(e){if(void 0===e)return\"undefined\";if(null===e)return\"null\";var t=typeof e;if(\"boolean\"===t)return\"boolean\";if(\"string\"===t)return\"string\";if(\"number\"===t)return\"number\";if(\"symbol\"===t)return\"symbol\";if(\"function\"===t)return\"GeneratorFunction\"===a(e)?\"generatorfunction\":\"function\";if(function(e){return Array.isArray?Array.isArray(e):e instanceof Array}(e))return\"array\";if(function(e){if(e.constructor&&\"function\"==typeof e.constructor.isBuffer)return e.constructor.isBuffer(e);return!1}(e))return\"buffer\";if(function(e){try{if(\"number\"==typeof e.length&&\"function\"==typeof e.callee)return!0}catch(t){if(-1!==t.message.indexOf(\"callee\"))return!0}return!1}(e))return\"arguments\";if(function(e){return e instanceof Date||\"function\"==typeof e.toDateString&&\"function\"==typeof e.getDate&&\"function\"==typeof e.setDate}(e))return\"date\";if(function(e){return e instanceof Error||\"string\"==typeof e.message&&e.constructor&&\"number\"==typeof e.constructor.stackTraceLimit}(e))return\"error\";if(function(e){return e instanceof RegExp||\"string\"==typeof e.flags&&\"boolean\"==typeof e.ignoreCase&&\"boolean\"==typeof e.multiline&&\"boolean\"==typeof e.global}(e))return\"regexp\";switch(a(e)){case\"Symbol\":return\"symbol\";case\"Promise\":return\"promise\";case\"WeakMap\":return\"weakmap\";case\"WeakSet\":return\"weakset\";case\"Map\":return\"map\";case\"Set\":return\"set\";case\"Int8Array\":return\"int8array\";case\"Uint8Array\":return\"uint8array\";case\"Uint8ClampedArray\":return\"uint8clampedarray\";case\"Int16Array\":return\"int16array\";case\"Uint16Array\":return\"uint16array\";case\"Int32Array\":return\"int32array\";case\"Uint32Array\":return\"uint32array\";case\"Float32Array\":return\"float32array\";case\"Float64Array\":return\"float64array\"}if(function(e){return\"function\"==typeof e.throw&&\"function\"==typeof e.return&&\"function\"==typeof e.next}(e))return\"generator\";switch(t=i.call(e)){case\"[object Object]\":return\"object\";case\"[object Map Iterator]\":return\"mapiterator\";case\"[object Set Iterator]\":return\"setiterator\";case\"[object String Iterator]\":return\"stringiterator\";case\"[object Array Iterator]\":return\"arrayiterator\"}return t.slice(8,-1).toLowerCase().replace(/\\s/g,\"\")};function a(e){return e.constructor?e.constructor.name:null}const s=\"@@__STRUCT__@@\",c=\"@@__KIND__@@\";function u(e){return!(!e||!e[s])}function l(e,t){return\"function\"==typeof e?e(t):e}var f=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e};class d{constructor(e,t,r){this.name=e,this.type=t,this.validate=r}}function p(e,t,r){if(u(e))return e[c];if(e instanceof d)return e;switch(o(e)){case\"array\":return e.length>1?b(e,t,r):v(e,t,r);case\"function\":return y(e,t,r);case\"object\":return m(e,t,r);case\"string\":{let n,i=!0;if(e.endsWith(\"?\")&&(i=!1,e=e.slice(0,-1)),e.includes(\"|\")){n=k(e.split(/\\s*\\|\\s*/g),t,r)}else if(e.includes(\"&\")){n=E(e.split(/\\s*&\\s*/g),t,r)}else n=w(e,t,r);return i||(n=g(n,void 0,r)),n}}throw new Error(`Invalid schema: ${e}`)}function h(e,t,r){if(\"array\"!==o(e))throw new Error(`Invalid schema: ${e}`);const n=e.map(e=>{try{return JSON.stringify(e)}catch(t){return String(e)}}).join(\" | \");return new d(\"enum\",n,(r=l(t))=>e.includes(r)?[void 0,r]:[{data:r,path:[],value:r,type:n}])}function y(e,t,r){if(\"function\"!==o(e))throw new Error(`Invalid schema: ${e}`);return new d(\"function\",\"<function>\",(r=l(t),n)=>{const i=e(r,n);let a,s={path:[],reason:null};switch(o(i)){case\"boolean\":a=i;break;case\"string\":a=!1,s.reason=i;break;case\"object\":a=!1,s=f({},s,i);break;default:throw new Error(`Invalid result: ${i}`)}return a?[void 0,r]:[f({type:\"<function>\",value:r,data:r},s)]})}function v(e,t,r){if(\"array\"!==o(e)||1!==e.length)throw new Error(`Invalid schema: ${e}`);const n=w(\"array\",void 0,r),i=p(e[0],void 0,r),a=`[${i.type}]`;return new d(\"list\",a,(e=l(t))=>{const[r,o]=n.validate(e);if(r)return r.type=a,[r];e=o;const s=[],c=[];for(let t=0;t<e.length;t++){const r=e[t],[n,o]=i.validate(r);n?(n.errors||[n]).forEach(r=>{r.path=[t].concat(r.path),r.data=e,s.push(r)}):c[t]=o}if(s.length){const e=s[0];return e.errors=s,[e]}return[void 0,c]})}function m(e,t,r){if(\"object\"!==o(e))throw new Error(`Invalid schema: ${e}`);const n=w(\"object\",void 0,r),i=[],a={};for(const o in e){i.push(o);const t=p(e[o],void 0,r);a[o]=t}const s=`{${i.join()}}`;return new d(\"object\",s,(e=l(t))=>{const[r]=n.validate(e);if(r)return r.type=s,[r];const i=[],o={},c=Object.keys(e),u=Object.keys(a);if(new Set(c.concat(u)).forEach(r=>{let n=e[r];const s=a[r];if(void 0===n&&(n=l(t&&t[r],e)),!s){const t={data:e,path:[r],value:n};return void i.push(t)}const[c,u]=s.validate(n,e);c?(c.errors||[c]).forEach(t=>{t.path=[r].concat(t.path),t.data=e,i.push(t)}):(r in e||void 0!==u)&&(o[r]=u)}),i.length){const e=i[0];return e.errors=i,[e]}return[void 0,o]})}function g(e,t,r){return k([e,\"undefined\"],t,r)}function w(e,t,r){if(\"string\"!==o(e))throw new Error(`Invalid schema: ${e}`);const{types:n}=r,i=n[e];if(\"function\"!==o(i))throw new Error(`Invalid type: ${e}`);const a=y(i,t),s=e;return new d(\"scalar\",s,e=>{const[t,r]=a.validate(e);return t?(t.type=s,[t]):[void 0,r]})}function b(e,t,r){if(\"array\"!==o(e))throw new Error(`Invalid schema: ${e}`);const n=e.map(e=>p(e,void 0,r)),i=w(\"array\",void 0,r),a=`[${n.map(e=>e.type).join()}]`;return new d(\"tuple\",a,(e=l(t))=>{const[r]=i.validate(e);if(r)return r.type=a,[r];const o=[],s=[],c=Math.max(e.length,n.length);for(let t=0;t<c;t++){const r=n[t],i=e[t];if(!r){const r={data:e,path:[t],value:i};s.push(r);continue}const[a,c]=r.validate(i);a?(a.errors||[a]).forEach(r=>{r.path=[t].concat(r.path),r.data=e,s.push(r)}):o[t]=c}if(s.length){const e=s[0];return e.errors=s,[e]}return[void 0,o]})}function k(e,t,r){if(\"array\"!==o(e))throw new Error(`Invalid schema: ${e}`);const n=e.map(e=>p(e,void 0,r)),i=n.map(e=>e.type).join(\" | \");return new d(\"union\",i,(e=l(t))=>{const r=[];for(const t of n){const[n,i]=t.validate(e);if(!n)return[void 0,i];r.push(n)}return r[0].type=i,r})}function E(e,t,r){if(\"array\"!==o(e))throw new Error(`Invalid schema: ${e}`);const n=e.map(e=>p(e,void 0,r)),i=n.map(e=>e.type).join(\" & \");return new d(\"intersection\",i,(e=l(t))=>{let r=e;for(const t of n){const[e,n]=t.validate(r);if(e)return e.type=i,[e];r=n}return[void 0,r]})}const j={any:p,dict:function(e,t,r){if(\"array\"!==o(e)||2!==e.length)throw new Error(`Invalid schema: ${e}`);const n=w(\"object\",void 0,r),i=p(e[0],void 0,r),a=p(e[1],void 0,r),s=`dict<${i.type},${a.type}>`;return new d(\"dict\",s,e=>{const r=l(t);e=r?f({},r,e):e;const[o]=n.validate(e);if(o)return o.type=s,[o];const c={},u=[];for(let t in e){const r=e[t],[n,o]=i.validate(t);if(n){(n.errors||[n]).forEach(r=>{r.path=[t].concat(r.path),r.data=e,u.push(r)});continue}t=o;const[s,l]=a.validate(r);s?(s.errors||[s]).forEach(r=>{r.path=[t].concat(r.path),r.data=e,u.push(r)}):c[t]=l}if(u.length){const e=u[0];return e.errors=u,[e]}return[void 0,c]})},enum:h,enums:function(e,t,r){return v([h(e,void 0)],t,r)},function:y,instance:function(e,t,r){const n=`instance<${e.name}>`;return new d(\"instance\",n,(r=l(t))=>r instanceof e?[void 0,r]:[{data:r,path:[],value:r,type:n}])},interface:function(e,t,r){if(\"object\"!==o(e))throw new Error(`Invalid schema: ${e}`);const n=[],i={};for(const o in e){n.push(o);const t=p(e[o],void 0,r);i[o]=t}const a=`{${n.join()}}`;return new d(\"interface\",a,e=>{const r=l(t);e=r?f({},r,e):e;const n=[],o=e;for(const a in i){let r=e[a];const s=i[a];void 0===r&&(r=l(t&&t[a],e));const[c,u]=s.validate(r,e);c?(c.errors||[c]).forEach(t=>{t.path=[a].concat(t.path),t.data=e,n.push(t)}):(a in e||void 0!==u)&&(o[a]=u)}if(n.length){const e=n[0];return e.errors=n,[e]}return[void 0,o]})},lazy:function(e,t,r){if(\"function\"!==o(e))throw new Error(`Invalid schema: ${e}`);let n,i;return n=new d(\"lazy\",\"lazy...\",t=>(i=e(),n.name=i.kind,n.type=i.type,n.validate=i.validate,n.validate(t)))},list:v,literal:function(e,t,r){const n=`literal: ${JSON.stringify(e)}`;return new d(\"literal\",n,(r=l(t))=>r===e?[void 0,r]:[{data:r,path:[],value:r,type:n}])},object:m,optional:g,partial:function(e,t,r){if(\"object\"!==o(e))throw new Error(`Invalid schema: ${e}`);const n=w(\"object\",void 0,r),i=[],a={};for(const o in e){i.push(o);const t=p(e[o],void 0,r);a[o]=t}const s=`{${i.join()},...}`;return new d(\"partial\",s,(e=l(t))=>{const[r]=n.validate(e);if(r)return r.type=s,[r];const i=[],o={};for(const n in a){let r=e[n];const s=a[n];void 0===r&&(r=l(t&&t[n],e));const[c,u]=s.validate(r,e);c?(c.errors||[c]).forEach(t=>{t.path=[n].concat(t.path),t.data=e,i.push(t)}):(n in e||void 0!==u)&&(o[n]=u)}if(i.length){const e=i[0];return e.errors=i,[e]}return[void 0,o]})},scalar:w,tuple:b,union:k,intersection:E,dynamic:function(e,t,r){if(\"function\"!==o(e))throw new Error(`Invalid schema: ${e}`);return new d(\"dynamic\",\"dynamic...\",(r=l(t),n)=>{const i=e(r,n);if(\"function\"!==o(i))throw new Error(`Invalid schema: ${i}`);const[a,s]=i.validate(r);return a?[a]:[void 0,s]})}},$={any:e=>void 0!==e};function _(e={}){const t=f({},$,e.types||{});function r(e,r,i={}){u(e)&&(e=e.schema);const o=j.any(e,r,f({},i,{types:t}));function a(e){if(this instanceof a)throw new Error(\"Invalid `new` keyword!\");return a.assert(e)}return Object.defineProperty(a,s,{value:!0}),Object.defineProperty(a,c,{value:o}),a.kind=o.name,a.type=o.type,a.schema=e,a.defaults=r,a.options=i,a.assert=(e=>{const[t,r]=o.validate(e);if(t)throw new n(t);return r}),a.test=(e=>{const[t]=o.validate(e);return!t}),a.validate=(e=>{const[t,r]=o.validate(e);return t?[new n(t)]:[void 0,r]}),a}return Object.keys(j).forEach(e=>{const n=j[e];r[e]=((e,i,o)=>{return r(n(e,i,f({},o,{types:t})),i,o)})}),r}[\"arguments\",\"array\",\"boolean\",\"buffer\",\"error\",\"float32array\",\"float64array\",\"function\",\"generatorfunction\",\"int16array\",\"int32array\",\"int8array\",\"map\",\"null\",\"number\",\"object\",\"promise\",\"regexp\",\"set\",\"string\",\"symbol\",\"uint16array\",\"uint32array\",\"uint8array\",\"uint8clampedarray\",\"undefined\",\"weakmap\",\"weakset\"].forEach(e=>{$[e]=(t=>o(t)===e)}),$.date=(e=>\"date\"===o(e)&&!isNaN(e));_()},206:function(e,t,r){\"use strict\";r.d(t,\"a\",function(){return n});const n=r(0).f`\n  <style>\n    ha-switch {\n      padding: 16px 0;\n    }\n    .side-by-side {\n      display: flex;\n    }\n    .side-by-side > * {\n      flex: 1;\n      padding-right: 4px;\n    }\n    .suffix {\n      margin: 0 8px;\n    }\n  </style>\n`},704:function(e,t,r){\"use strict\";r.r(t),r.d(t,\"HuiIframeCardEditor\",function(){return h});var n=r(0),i=(r(80),r(189)),o=r(14),a=r(206);function s(e){var t,r=d(e.key);\"method\"===e.kind?t={value:e.value,writable:!0,configurable:!0,enumerable:!1}:\"get\"===e.kind?t={get:e.value,configurable:!0,enumerable:!1}:\"set\"===e.kind?t={set:e.value,configurable:!0,enumerable:!1}:\"field\"===e.kind&&(t={configurable:!0,writable:!0,enumerable:!0});var n={kind:\"field\"===e.kind?\"field\":\"method\",key:r,placement:e.static?\"static\":\"field\"===e.kind?\"own\":\"prototype\",descriptor:t};return e.decorators&&(n.decorators=e.decorators),\"field\"===e.kind&&(n.initializer=e.value),n}function c(e,t){void 0!==e.descriptor.get?t.descriptor.get=e.descriptor.get:t.descriptor.set=e.descriptor.set}function u(e){return e.decorators&&e.decorators.length}function l(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function f(e,t){var r=e[t];if(void 0!==r&&\"function\"!=typeof r)throw new TypeError(\"Expected '\"+t+\"' to be a function\");return r}function d(e){var t=function(e,t){if(\"object\"!=typeof e||null===e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var n=r.call(e,t||\"default\");if(\"object\"!=typeof n)return n;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===t?String:Number)(e)}(e,\"string\");return\"symbol\"==typeof t?t:String(t)}const p=Object(i.a)({type:\"string\",title:\"string?\",url:\"string?\",aspect_ratio:\"string?\"});let h=function(e,t,r,n){var i=function(){var e={elementsDefinitionOrder:[[\"method\"],[\"field\"]],initializeInstanceElements:function(e,t){[\"method\",\"field\"].forEach(function(r){t.forEach(function(t){t.kind===r&&\"own\"===t.placement&&this.defineClassElement(e,t)},this)},this)},initializeClassElements:function(e,t){var r=e.prototype;[\"method\",\"field\"].forEach(function(n){t.forEach(function(t){var i=t.placement;if(t.kind===n&&(\"static\"===i||\"prototype\"===i)){var o=\"static\"===i?e:r;this.defineClassElement(o,t)}},this)},this)},defineClassElement:function(e,t){var r=t.descriptor;if(\"field\"===t.kind){var n=t.initializer;r={enumerable:r.enumerable,writable:r.writable,configurable:r.configurable,value:void 0===n?void 0:n.call(e)}}Object.defineProperty(e,t.key,r)},decorateClass:function(e,t){var r=[],n=[],i={static:[],prototype:[],own:[]};if(e.forEach(function(e){this.addElementPlacement(e,i)},this),e.forEach(function(e){if(!u(e))return r.push(e);var t=this.decorateElement(e,i);r.push(t.element),r.push.apply(r,t.extras),n.push.apply(n,t.finishers)},this),!t)return{elements:r,finishers:n};var o=this.decorateConstructor(r,t);return n.push.apply(n,o.finishers),o.finishers=n,o},addElementPlacement:function(e,t,r){var n=t[e.placement];if(!r&&-1!==n.indexOf(e.key))throw new TypeError(\"Duplicated element (\"+e.key+\")\");n.push(e.key)},decorateElement:function(e,t){for(var r=[],n=[],i=e.decorators,o=i.length-1;o>=0;o--){var a=t[e.placement];a.splice(a.indexOf(e.key),1);var s=this.fromElementDescriptor(e),c=this.toElementFinisherExtras((0,i[o])(s)||s);e=c.element,this.addElementPlacement(e,t),c.finisher&&n.push(c.finisher);var u=c.extras;if(u){for(var l=0;l<u.length;l++)this.addElementPlacement(u[l],t);r.push.apply(r,u)}}return{element:e,finishers:n,extras:r}},decorateConstructor:function(e,t){for(var r=[],n=t.length-1;n>=0;n--){var i=this.fromClassDescriptor(e),o=this.toClassDescriptor((0,t[n])(i)||i);if(void 0!==o.finisher&&r.push(o.finisher),void 0!==o.elements){e=o.elements;for(var a=0;a<e.length-1;a++)for(var s=a+1;s<e.length;s++)if(e[a].key===e[s].key&&e[a].placement===e[s].placement)throw new TypeError(\"Duplicated element (\"+e[a].key+\")\")}}return{elements:e,finishers:r}},fromElementDescriptor:function(e){var t={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(t,Symbol.toStringTag,{value:\"Descriptor\",configurable:!0}),\"field\"===e.kind&&(t.initializer=e.initializer),t},toElementDescriptors:function(e){var t;if(void 0!==e)return(t=e,function(e){if(Array.isArray(e))return e}(t)||function(e){if(Symbol.iterator in Object(e)||\"[object Arguments]\"===Object.prototype.toString.call(e))return Array.from(e)}(t)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()).map(function(e){var t=this.toElementDescriptor(e);return this.disallowProperty(e,\"finisher\",\"An element descriptor\"),this.disallowProperty(e,\"extras\",\"An element descriptor\"),t},this)},toElementDescriptor:function(e){var t=String(e.kind);if(\"method\"!==t&&\"field\"!==t)throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or \"field\", but a decorator created an element descriptor with .kind \"'+t+'\"');var r=d(e.key),n=String(e.placement);if(\"static\"!==n&&\"prototype\"!==n&&\"own\"!==n)throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\", \"prototype\" or \"own\", but a decorator created an element descriptor with .placement \"'+n+'\"');var i=e.descriptor;this.disallowProperty(e,\"elements\",\"An element descriptor\");var o={kind:t,key:r,placement:n,descriptor:Object.assign({},i)};return\"field\"!==t?this.disallowProperty(e,\"initializer\",\"A method descriptor\"):(this.disallowProperty(i,\"get\",\"The property descriptor of a field descriptor\"),this.disallowProperty(i,\"set\",\"The property descriptor of a field descriptor\"),this.disallowProperty(i,\"value\",\"The property descriptor of a field descriptor\"),o.initializer=e.initializer),o},toElementFinisherExtras:function(e){var t=this.toElementDescriptor(e),r=f(e,\"finisher\"),n=this.toElementDescriptors(e.extras);return{element:t,finisher:r,extras:n}},fromClassDescriptor:function(e){var t={kind:\"class\",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(t,Symbol.toStringTag,{value:\"Descriptor\",configurable:!0}),t},toClassDescriptor:function(e){var t=String(e.kind);if(\"class\"!==t)throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator created a class descriptor with .kind \"'+t+'\"');this.disallowProperty(e,\"key\",\"A class descriptor\"),this.disallowProperty(e,\"placement\",\"A class descriptor\"),this.disallowProperty(e,\"descriptor\",\"A class descriptor\"),this.disallowProperty(e,\"initializer\",\"A class descriptor\"),this.disallowProperty(e,\"extras\",\"A class descriptor\");var r=f(e,\"finisher\"),n=this.toElementDescriptors(e.elements);return{elements:n,finisher:r}},runClassFinishers:function(e,t){for(var r=0;r<t.length;r++){var n=(0,t[r])(e);if(void 0!==n){if(\"function\"!=typeof n)throw new TypeError(\"Finishers must return a constructor.\");e=n}}return e},disallowProperty:function(e,t,r){if(void 0!==e[t])throw new TypeError(r+\" can't have a .\"+t+\" property.\")}};return e}();if(n)for(var o=0;o<n.length;o++)i=n[o](i);var a=t(function(e){i.initializeInstanceElements(e,p.elements)},r),p=i.decorateClass(function(e){for(var t=[],r=function(e){return\"method\"===e.kind&&e.key===o.key&&e.placement===o.placement},n=0;n<e.length;n++){var i,o=e[n];if(\"method\"===o.kind&&(i=t.find(r)))if(l(o.descriptor)||l(i.descriptor)){if(u(o)||u(i))throw new ReferenceError(\"Duplicated methods (\"+o.key+\") can't be decorated.\");i.descriptor=o.descriptor}else{if(u(o)){if(u(i))throw new ReferenceError(\"Decorators can't be placed on different accessors with for the same property (\"+o.key+\").\");i.decorators=o.decorators}c(o,i)}else t.push(o)}return t}(a.d.map(s)),e);return i.initializeClassElements(a.F,p.elements),i.runClassFinishers(a.F,p.finishers)}([Object(n.d)(\"hui-iframe-card-editor\")],function(e,t){return{F:class extends t{constructor(...t){super(...t),e(this)}},d:[{kind:\"field\",decorators:[Object(n.g)()],key:\"hass\",value:void 0},{kind:\"field\",decorators:[Object(n.g)()],key:\"_config\",value:void 0},{kind:\"method\",key:\"setConfig\",value:function(e){e=p(e),this._config=e}},{kind:\"get\",key:\"_title\",value:function(){return this._config.title||\"\"}},{kind:\"get\",key:\"_url\",value:function(){return this._config.url||\"\"}},{kind:\"get\",key:\"_aspect_ratio\",value:function(){return this._config.aspect_ratio||\"\"}},{kind:\"method\",key:\"render\",value:function(){return this.hass?n.f`\n      ${a.a}\n      <div class=\"card-config\">\n        <paper-input\n          .label=\"${this.hass.localize(\"ui.panel.lovelace.editor.card.generic.url\")} (${this.hass.localize(\"ui.panel.lovelace.editor.card.config.required\")})\"\n          .value=\"${this._url}\"\n          .configValue=\"${\"url\"}\"\n          @value-changed=\"${this._valueChanged}\"\n        ></paper-input>\n        <div class=\"side-by-side\">\n          <paper-input\n            .label=\"${this.hass.localize(\"ui.panel.lovelace.editor.card.generic.title\")} (${this.hass.localize(\"ui.panel.lovelace.editor.card.config.optional\")})\"\n            .value=\"${this._title}\"\n            .configValue=\"${\"title\"}\"\n            @value-changed=\"${this._valueChanged}\"\n          ></paper-input>\n          <paper-input\n            .label=\"${this.hass.localize(\"ui.panel.lovelace.editor.card.generic.aspect_ratio\")} (${this.hass.localize(\"ui.panel.lovelace.editor.card.config.optional\")})\"\n            type=\"number\"\n            .value=\"${Number(this._aspect_ratio.replace(\"%\",\"\"))}\"\n            .configValue=\"${\"aspect_ratio\"}\"\n            @value-changed=\"${this._valueChanged}\"\n          ></paper-input>\n        </div>\n      </div>\n    `:n.f``}},{kind:\"method\",key:\"_valueChanged\",value:function(e){if(!this._config||!this.hass)return;const t=e.target;let r=t.value;\"aspect_ratio\"===t.configValue&&t.value&&(r+=\"%\"),this[`_${t.configValue}`]!==r&&(t.configValue&&(\"\"===t.value?delete this._config[t.configValue]:this._config=Object.assign({},this._config,{[t.configValue]:r})),Object(o.a)(this,\"config-changed\",{config:this._config}))}}]}},n.a)}}]);","extractedComments":[]}